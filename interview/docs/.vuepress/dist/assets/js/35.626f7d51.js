(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{346:function(t,e,a){"use strict";a.r(e);var r=a(14),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"http-发展历史"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http-发展历史"}},[t._v("#")]),t._v(" Http 发展历史")]),t._v(" "),a("h3",{attrs:{id:"web-始祖-http"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#web-始祖-http"}},[t._v("#")]),t._v(" WEB 始祖 HTTP")]),t._v(" "),a("p",[t._v("超文本传输协议，建立在 TCP 协议之上，TCP 建立连接 3 次握手，断开连接的 4 次挥手。")]),t._v(" "),a("h3",{attrs:{id:"http-1-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http-1-1"}},[t._v("#")]),t._v(" HTTP 1.1")]),t._v(" "),a("ul",[a("li",[t._v("引入了更多的缓存控制策略：Entity tag，If-Unmodified-Since，If-Match，If-None-Match")]),t._v(" "),a("li",[t._v("请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206")]),t._v(" "),a("li",[t._v("新增了 24 个错误状态响应码，409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除")]),t._v(" "),a("li",[t._v("HTTP 1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）")]),t._v(" "),a("li",[t._v("支持长连接 "),a("code",[t._v("connection: keep-alive")])])]),t._v(" "),a("h3",{attrs:{id:"http-2-0"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http-2-0"}},[t._v("#")]),t._v(" HTTP 2.0")]),t._v(" "),a("p",[t._v("基于 https")]),t._v(" "),a("ul",[a("li",[t._v("支持二进制格式传输")]),t._v(" "),a("li",[t._v("多路复用，即连接共享，一个 request 对应一个 id，这样一个连接上可以有多个 request，每个连接的 request 可以随机的混杂在一起，接收方可以根据 request 的 id 将 request 再归属到各自不同的服务端请求里面")]),t._v(" "),a("li",[t._v("使用 encoder 来减少需要传输的 header 大小")]),t._v(" "),a("li",[t._v("服务端推送")])]),t._v(" "),a("h3",{attrs:{id:"http-3-0"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http-3-0"}},[t._v("#")]),t._v(" HTTP 3.0")]),t._v(" "),a("p",[t._v("称为 HTTP over QUIC，是基于 UDP 的安全可靠的 HTTP2.0 协议。")]),t._v(" "),a("ul",[a("li",[t._v("减少了 TCP 三次握手及 TLS 握手时间，连接建立时只需要一次交互，半个握手的时间")]),t._v(" "),a("li",[t._v("多路复用丢包时的线头阻塞问题：QUIC 保留了 HTTP2.0 多路复用的特性，但是即使在多路复用过程中，同一个 TCP 连接上有多个 stream，假如其中一个stream 丢包，在重传前后续的 stream 都会受到影响，而 3.0 中一个连接上的多个 stream 之间没有依赖。所以当发生丢包时，只会影响当前的 stream，也就避免了线头阻塞问题。")]),t._v(" "),a("li",[t._v("优化重传策略：以往的版本是在发送端为每一个封包标记一个编号，接收端在收到封包时，就会回传一个带有对应编号的ACK封包给发送端。当发送端在超过一定时间之后还没有收到回传的 这样的机制就会带来一些问题，假设发送端总共对同一个封包发送了两次 (初始 + 重传)，使用的都是同一个编号 N。之后发送端在拿到编号 N 封包的回传 ACK 时，将无法判断这个带有编号 N 的 ACK 来自哪一个包，加大后续的重传计算的耗时。而 3.0 发送端在传送封包时，初始与重传的每一个封包都改用一个新的编号，unique packet number，每一个编号都唯一而且严格递增。")]),t._v(" "),a("li",[t._v("流量控制：通过流量控制可以限制客户端传输资料量的大小，限制单一 Stream 可以占用的最大 buffer size。")])])])}),[],!1,null,null,null);e.default=s.exports}}]);