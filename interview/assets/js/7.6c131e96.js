(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{228:function(s,t,a){s.exports=a.p+"assets/img/ast1.e433efac.jpg"},229:function(s,t,a){s.exports=a.p+"assets/img/ast2.7979c98c.jpg"},230:function(s,t,a){s.exports=a.p+"assets/img/ast3.f8f97d3c.jpg"},255:function(s,t,a){"use strict";a.r(t);var v=a(0),e=Object(v.a)({},(function(){var s=this,t=s.$createElement,v=s._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[v("h1",{attrs:{id:"v8-js-执行过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#v8-js-执行过程"}},[s._v("#")]),s._v(" V8 JS 执行过程")]),s._v(" "),v("p",[s._v("一段 JavaScript 代码放在 V8 当中究竟是如何执行的呢？")]),s._v(" "),v("p",[s._v("机器是读不懂 JS 代码，机器只能理解特定的机器码，那如果要让 JS 的逻辑在机器上运行起来，就必须将 JS 的代码翻译成机器码，然后让机器识别。JS属于解释型语言，对于解释型的语言说，解释器会对源代码做如下分析:")]),s._v(" "),v("ul",[v("li",[s._v("通过词法分析和语法分析生成 AST(抽象语法树)")]),s._v(" "),v("li",[s._v("生成字节码")])]),s._v(" "),v("p",[s._v("然后解释器根据字节码来执行程序。")]),s._v(" "),v("h3",{attrs:{id:"生成-ast"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#生成-ast"}},[s._v("#")]),s._v(" 生成 AST")]),s._v(" "),v("p",[s._v("生成 AST 分为两步——词法分析和语法分析。")]),s._v(" "),v("p",[s._v("词法分析即分词，它的工作就是将一行行的代码分解成一个个token。 比如下面一行代码：")]),s._v(" "),v("div",{staticClass:"language-js line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-js"}},[v("code",[v("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" name "),v("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),v("span",{pre:!0,attrs:{class:"token string"}},[s._v("'sanyuan'")]),s._v("\n")])]),s._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[s._v("1")]),v("br")])]),v("p",[s._v("其中会把句子分解成四个部分：")]),s._v(" "),v("p",[v("img",{attrs:{src:a(228),alt:""}})]),s._v(" "),v("p",[s._v("即解析成了四个token，这就是词法分析的作用。")]),s._v(" "),v("p",[s._v("接下来语法分析阶段，将生成的这些 token 数据，根据一定的语法规则转化为AST。举个例子：")]),s._v(" "),v("div",{staticClass:"language-js line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-js"}},[v("code",[v("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" name "),v("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),v("span",{pre:!0,attrs:{class:"token string"}},[s._v("'sanyuan'")]),s._v("\nconsole"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[s._v("log")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("name"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n")])]),s._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[s._v("1")]),v("br"),v("span",{staticClass:"line-number"},[s._v("2")]),v("br")])]),v("p",[s._v("最后生成的 AST 是这样的：")]),s._v(" "),v("p",[v("img",{attrs:{src:a(229),alt:""}})]),s._v(" "),v("p",[s._v("当生成了 AST 之后，编译器/解释器后续的工作都要依靠 AST 而不是源代码。顺便补充一句，babel 的工作原理就是将 ES5 的代码解析生成 "),v("code",[s._v("ES5 的 AST")]),s._v("，然后将 "),v("code",[s._v("ES5 的 AST")]),s._v(" 转换为 "),v("code",[s._v("ES6 的 AST")]),s._v(",最后才将 "),v("code",[s._v("ES6 的 AST")]),s._v(" 转化为具体的 "),v("code",[s._v("ES6")]),s._v(" 代码。")]),s._v(" "),v("p",[s._v("回到 V8 本身，生成 AST 后，接下来会生成执行上下文。")]),s._v(" "),v("h3",{attrs:{id:"生成字节码"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#生成字节码"}},[s._v("#")]),s._v(" 生成字节码")]),s._v(" "),v("p",[s._v("开头就已经提到过了，生成 AST 之后，直接通过 V8 的解释器(也叫Ignition)来生成字节码。但是字节码并不能让机器直接运行，那你可能就会说了，不能执行还转成字节码干嘛，直接把 AST 转换成机器码不就得了，让机器直接执行。确实，在 V8 的早期是这么做的，但后来因为机器码的体积太大，引发了严重的内存占用问题。")]),s._v(" "),v("p",[s._v("给一张对比图让大家直观地感受以下三者代码量的差异：")]),s._v(" "),v("p",[v("img",{attrs:{src:a(230),alt:""}})]),s._v(" "),v("p",[s._v("很容易得出，字节码是比机器码轻量得多的代码。那 V8 为什么要使用字节码，字节码到底是个什么东西？")]),s._v(" "),v("blockquote",[v("p",[s._v("子节码是介于AST 和 机器码之间的一种代码，但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码然后执行。")])]),s._v(" "),v("p",[s._v("字节码仍然需要转换为机器码，但和原来不同的是，现在不用一次性将全部的字节码都转换成机器码，而是通过解释器来逐行执行字节码，省去了生成二进制文件的操作，这样就大大降低了内存的压力。")]),s._v(" "),v("h3",{attrs:{id:"执行代码"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#执行代码"}},[s._v("#")]),s._v(" 执行代码")]),s._v(" "),v("p",[s._v("接下来，就进入到字节码解释执行的阶段啦！")]),s._v(" "),v("p",[s._v("在执行字节码的过程中，如果发现某一部分代码重复出现，那么 V8 将它记做热点代码(HotSpot)，然后将这么代码编译成机器码保存起来，这个用来编译的工具就是V8的编译器(也叫做TurboFan) , 因此在这样的机制下，代码执行的时间越久，那么执行效率会越来越高，因为有越来越多的字节码被标记为热点代码，遇到它们时直接执行相应的机器码，不用再次将转换为机器码。")]),s._v(" "),v("p",[s._v("其实当你听到有人说 JS 就是一门解释器语言的时候，其实这个说法是有问题的。因为字节码不仅配合了解释器，而且还和编译器打交道，所以 JS 并不是完全的解释型语言。而编译器和解释器的根本区别在于前者会编译生成二进制文件但后者不会。")]),s._v(" "),v("p",[s._v("并且，这种字节码跟编译器和解释器结合的技术，我们称之为即时编译，也就是我们经常听到的JIT。")]),s._v(" "),v("h3",{attrs:{id:"总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[s._v("#")]),s._v(" 总结")]),s._v(" "),v("p",[s._v("这就是 V8 中执行一段JS代码的整个过程，梳理一下：")]),s._v(" "),v("ul",[v("li",[s._v("首先通过词法分析和语法分析生成 AST")]),s._v(" "),v("li",[s._v("将 AST 转换为字节码")]),s._v(" "),v("li",[s._v("由解释器逐行执行字节码，遇到热点代码启动编译器进行编译，生成对应的机器码，以优化执行效率")])])])}),[],!1,null,null,null);t.default=e.exports}}]);