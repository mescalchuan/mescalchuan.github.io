[{"title":"快速开发基于vue的app应用——vue-app-cli","url":"/2018/09/27/2018-09-27-technology-vue-app-cli/","content":"\n![](https://upload-images.jianshu.io/upload_images/1495096-1d5b56057c3a3840.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 一个能够让你快速构建基于`vue`的`app`多页应用脚手架，可独立开发`h5 app`或集成到`hbuilder`开发原生应用。\n\n### [文档地址](https://mescalchuan.github.io/vue-app-cli)\n\n#### vue-cli\n之所以不使用官方的`vue-cli`构建应用是因为：\n* `vue-cli`需要自己实现多页面构建。\n* 在开发环境（`npm start`）下会创建服务器，一切构建结果都存放在内存中，本地无法访问，导致`app`变为空白页。\n* 只有在生产环境（`npm run build`）下才会构建到本地，却失去了对模块的实时监控。\n* `webpack`拆分太细，功能太全，很多功能在`app`端都不会用到。\n\n以上不足均可以自行修改`vue-cli`实现构建最优化，出于时间成本的考虑，最终决定在已有的`angular-m-cli`的基础上完成适合`app`开发的脚手架构建。\n\n#### vue-app-cli\n可以快速构建基于vue的app多页应用，对`h5页面app`和`dcloud原生app`都十分友好。\n\n它实现了以下功能：\n* 快速生成`app`模板\n* 快速创建新页面\n* 支持`es6`\n* 支持`.vue`文件\n* 基于`sass`编写样式文件\n* 模块导入样式文件\n* 错误映射\n\n### 参考\n[vue-cli](https://github.com/vuejs/vue-cli)、[教你从零开始搭建一款前端脚手架工具](https://segmentfault.com/a/1190000006190814)\n\n\n\n","tags":["vue"],"categories":["技术博客"]},{"title":"初探微信小程序之小川天气","url":"/2018/08/29/2018-08-29-technology-weixin/","content":"微信小程序可以说是当下很火热的应用了。在好奇心的作用下，通读了一遍之后便开始上手撸了一个很简单的天气应用——小川天气。\n\n![小川天气](https://upload-images.jianshu.io/upload_images/1495096-6895c3ecc8731c6c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![首页](https://upload-images.jianshu.io/upload_images/1495096-6b52de2058465306.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![生活指数](https://upload-images.jianshu.io/upload_images/1495096-097faac85ddac982.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n![导航](https://upload-images.jianshu.io/upload_images/1495096-fb080aab4403782b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![城市选择](https://upload-images.jianshu.io/upload_images/1495096-1239aa459b6252ae.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n目前已经发布正式版本，你可以直接在微信中搜索`小川天气`来使用。\n\n小程序的文档已经很完善了，通读一遍后上手写代码并不是很难，下面主要讲一下本人在开发微信小程序的一些感触（坑）~\n\n#### SetData\n类似于`React`的`setState`，用于更改状态，但小程序做得更加智能，你完全可以直接修改数组中的某一项的值而不必再克隆一份出来：\n```\n//小程序\nthis.setData({\n    \"arr[0]\": \"new value\"\n})\n//react\nlet _arr = JSON.parse(JSON.stringify(this.state.arr));\n_arr[0] = \"new value\";\nthis.setState({\n    arr: _arr\n})\n```\n\n修改对象也是如此：\n```\n//小程序\nthis.setData({\n    \"obj.name\": \"mescal-chuan\"\n})\n//react\nlet _obj = JSON.parse(JSON.stringify(this.state.obj));\n_obj.name = \"mescal-chuan\";\nthis.setState({\n    obj: _obj\n})\n```\n#### 页面中绑定函数\n使用`bind`指令进行函数绑定：\n```\n <view bindtap=\"openModal\"></view>\n```\n看起来和`vue`差不多，然而如果你想给这个函数传递一些参数就比较恶心了：\n```\n <view bindtap=\"openModal\" data-index=\"{{index}}\"></view>\n//js\nopenModal() {\n    const currentIndex = e.currentTarget.dataset.index;\n    this.setData({\n      currentIndex\n    })\n    wx.showModal({\n        title: config.lifeStyleTitle(activity[currentIndex].type),\n        content: activity[currentIndex].txt,\n        showCancel: false\n    })\n}\n```\n\n\n#### 页面通信\n以本应用为例，用户在城市选择页选择新的城市之后，需要通知首页刷新数据。在单页应用中我们可以使用`redux`或`vuex`这类状态管理库实现状态的全局化；在使用`dcloud`这类`webapp`开发时，我们可以用它们自己内部定制的事件传递来实现跨页面通信。那么在微信小程序中，你可以获取一个页面的实例，然后直接调用该页面内部的方法。\n```\n//city.js\nselectCity(e) {\n    const keyIndex = e.currentTarget.dataset.key;\n    const childIndex = e.currentTarget.dataset.child;\n    const pages = getCurrentPages();\n    const homePage = pages[0];\n    //调用首页的方法来刷新首页数据\n    homePage.getNewCity(null, keyIndex, childIndex);\n    wx.navigateBack();\n}\n```\n\n#### 指令中使用函数\n很遗憾，一个页面内部的函数只能用在事件绑定中，你必须使用`wxs`来实现在页面中访问内部函数。它是小程序的一套脚本语言，配合我们的`wxml`一起完成页面构建。\n\n```\n//index.vue\n<template>\n    <p>{{getDateText(index)}}</p>\n</template>\n<script>\n    export default {\n        ...\n        methods: {\n            getDateText(index) {\n                return xxx;\n            }\n        }\n        ...\n    }\n</script>\n```\n\n```\n//index.wxs\nvar getDateText = function(index) {\n    return xxx;\n}\nmodule.exports = {\n    getDateText: getDateText\n}\n//index.wxml\n<wxs src=\"./index.wxs\" module=\"forecast\"/>\n<text>{{forecast.getDateText(index)}}</text>\n```\n#### UI\n小程序的组件到目前为止还不是很完善，一些比较常用的组件需要自己实现，比如：抽屉、模态框、Loading等。当然，`github`上也有一些比较成熟的UI库供你直接使用，比如本项目中用到的[小程序版echarts](https://github.com/ecomfe/echarts-for-weixin)。\n\n#### 总结\n目前为止遇到的坑大致如此，由于只是开发了一个简单应用，所涉及到的知识只是皮毛，后续有时间会继续开发一个复杂应用。","tags":["小程序"],"categories":["技术博客"]},{"title":"基于React和Node实现一个食物热量参考应用","url":"/2018/07/31/2018-07-31-technology-node-health/","content":"利用业余时间，自己做了一个食物热量参考网站，数据参考自一个app`食物库`。技术栈使用了`sass`+`react`+`react-router`+`redux`+`antd`+`express`+`mongoose`。\n\n![node-health](https://upload-images.jianshu.io/upload_images/1495096-ffa2512a13209649.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 一、How To Use\n#### 下载\n首先将代码clone到本地\n```\ngit clone https://github.com/mescalchuan/node-health.git\n```\n#### 安装依赖包\n```\ncd node-health && npm i\n```\n#### 引入数据并启动mongodb服务\n要确保你已经安装了`mongodb`，然后在自己电脑上新建数据库文件夹（我的是E:\\mongodbData\\db）。在`mongodb`安装目录的`bin`文件夹下启动`mongodb`服务：\n```\nmongodb --dbpath=\"E:\\mongodbData\\db\" --port 27017 -journal\n```\n\n启动成功后，数据库是没有任何数据的，我们需要将一些默认数据导入进来，我已经将这些数据导出成`json`了，你只需要重开一个命令行并输入：\n```\nmongoexport -d db -c category -o \"E:node-health\\db\\category.json\" --type json --port 27017\nmongoexport -d db -c food -o \"E:node-health\\db\\food.json\" --type json --port 27017\n```\n这里推荐一个超轻量级数据库操作工具：[adminMongo](https://github.com/mrvautin/adminMongo)。\n\n\n![adminMongo](https://upload-images.jianshu.io/upload_images/1495096-e7118805d7624887.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n如果数据导入成功，那么在`food`和`category`表里会看到导入进来的数据，否则，你需要在`adminMongo`里自己手动创建这两张表，然后再导入数据就可以了。\n\n#### 启动前端服务\n```\ncd /e/node-health\nwebpack --watch\n```\n\n用户：`http://localhost:8888`\n管理员：`http://localhost:8888/admin.html`，用户名和密码均为admin\n#### 启动后台服务\n```\ncd /e/node-health\nnode app\n```\n项目截图\n\n![node-health](https://upload-images.jianshu.io/upload_images/1495096-ffa2512a13209649.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![分类](https://upload-images.jianshu.io/upload_images/1495096-f2d395dcca74ce45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![推荐食物](https://upload-images.jianshu.io/upload_images/1495096-b314d35f12de3cf7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![高热量食物](https://upload-images.jianshu.io/upload_images/1495096-8ef8a51aea0bb38d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![食物详情](https://upload-images.jianshu.io/upload_images/1495096-5a308abbb2a3d4cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![搜索结果页](https://upload-images.jianshu.io/upload_images/1495096-a9bf6ad837bd0be8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![管理员登录页](https://upload-images.jianshu.io/upload_images/1495096-45ad6317e2122e73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![后台管理页](https://upload-images.jianshu.io/upload_images/1495096-85fbba304bf1b718.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![添加食物](https://upload-images.jianshu.io/upload_images/1495096-6a581c610961d210.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![食物详情](https://upload-images.jianshu.io/upload_images/1495096-55d878686ece6c52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![修改食物](https://upload-images.jianshu.io/upload_images/1495096-55117aecde6650fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![删除食物](https://upload-images.jianshu.io/upload_images/1495096-4b7fe599c24563ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 二、说明\n该项目适用于有一定前端基础（包括`react`和`redux`）和`node.js`基础的同学，如果你正在学习`node`，但又无法将一系列知识体系串起来，那么本项目同样适合你~\n\n### 三、环境搭建\n#### 整体目录结构\n![](https://upload-images.jianshu.io/upload_images/1495096-d0b177f78d6bc024.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n* controller：后端控制层\n* db：导出的数据库`json`文件\n* model：后端模型层\n* router：后端路由\n* src：前端代码\n* admin.ejs：管理员页面（模板引擎）\n* app.js：后端根文件\n* index.ejs：用户页面（模板引擎）\n* webpack.config.js：`webpack`配置文件\n\n#### 前端\n目录结构如下：\n\n![](https://upload-images.jianshu.io/upload_images/1495096-d95fff03f6252fab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n从头搭建`webpack`吧，由于用到了后台模板引擎，因此我们就不再单独用`webpack`启动一个服务了。\n```\nvar path = require(\"path\");\nvar webpack = require(\"webpack\");\n\nvar OpenBrowserPlugin = require(\"open-browser-webpack-plugin\");\nvar ExtractTextPlugin = require(\"extract-text-webpack-plugin\");\nvar OptimizeCSSPlugin = require(\"optimize-css-assets-webpack-plugin\");\n//提高loader的解析速度\nvar HappyPack = require(\"happypack\");\nvar CommonsChunkPlugin = webpack.optimize.CommonsChunkPlugin;\nvar NoEmitOnErrorsPlugin = webpack.NoEmitOnErrorsPlugin;\nvar UglifyJsPlugin = webpack.optimize.UglifyJsPlugin;\n\n//externals配置的对象在生产环境下会自动引入CDN的对象，不会将node_modules下的文件打包进来\nvar externals = {\n    \"React\": \"react\",\n    \"ReactDOM\": \"react-dom\"\n}\n//配置多入口文件，包括用户和管理员\nvar entry = {\n    \"index\": \"./src/index.js\",\n    \"admin\": \"./src/admin.js\"\n};\n\n//最基本的webpack配置\nvar webpackConfig = {\n    entry: entry,\n    output: {\n        path: path.resolve(__dirname, \"src/build\"),\n        filename: \"[name].bundle.js\"\n    },\n    externals: externals,\n    devtool: \"source-map\",\n    module: {\n        rules: [\n            {\n                test: /\\.js$/,\n                exclude: /node_modules/,\n                use: [\"happypack/loader?id=babel\"]\n            },\n            {\n                test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,\n                loader: \"url-loader\",\n                options: {\n                    limit: 8192,\n                    name: \"[name].[ext]\"\n                }\n            }, {\n                test: /\\.css$/,\n                exclude: /node_modules/,\n                use: ExtractTextPlugin.extract({\n                    fallback: \"style-loader\",\n                    use: [\"css-loader\"]\n                })\n            }, \n            {\n                test: /\\.scss$/,\n                exclude: /node_modules/,\n                use: ExtractTextPlugin.extract({\n                    use: [\"css-loader\", \"sass-loader\"],\n                    fallback: \"style-loader\"\n                })\n            }\n        ]\n    },\n    resolve: {\n        extensions: [\".js\", \".json\"]\n    },\n    plugins: [\n        new HappyPack({\n            id: \"babel\",\n            loaders: [{\n                loader: \"babel-loader\",\n                options: {\n                    presets: [\"es2015\", \"stage-2\", \"react\"]\n                }\n            }]\n        }),\n        new CommonsChunkPlugin({\n            name: [\"vendor\"],\n            filename: \"vendor.bundle.js\",\n            minChunks: Infinity\n        }),\n        new NoEmitOnErrorsPlugin(),\n        new OpenBrowserPlugin({\n            url: \"http://localhost:8888\"\n        }),\n        new ExtractTextPlugin(\"[name].bundle.css\", {\n            allChunks: false\n        }),\n        //为了方便调试，暂时屏蔽\n        // new UglifyJsPlugin({\n        //     minimize: true,\n        //     output: {\n        //         comments: false,\n        //         beautify: false\n        //     },\n        //     compress: {\n        //         warnings: false,\n        //         drop_console: true,\n        //         collapse_vars: true,\n        //         reduce_vars: true\n        //     }\n        // }),\n        new OptimizeCSSPlugin()\n    ]\n};\n\nmodule.exports = webpackConfig;\n```\n之后，使用`webpack --watch`既可以完成打包。\n\n#### 后端\n后端基于`express`和`mongoose`，用到了`express-session`和`body-parser`，所以我们先把这些包安装好：\n```\nnpm i express mongoose express-session body-parser -S\n```\n\n然后我们看一下`app.js`：\n```\nconst express = require(\"express\");\nconst mongoose = require(\"mongoose\");\nconst cookieParser = require(\"cookie-parser\");\nconst bodyParser = require(\"body-parser\");\nconst session = require(\"express-session\");\n\nconst app = express();\n\napp.use(cookieParser());\n//解析post请求\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: false }));\n//设置session\napp.use(session({\n    secret: 'keyboard cat',\n    resave: false,\n    saveUninitialized: true\n}));\n\n//设置存放模板文件的目录\napp.set(\"views\", __dirname);\n//设置模板引擎为ejs\napp.set(\"view engine\", \"ejs\");\n//访问静态资源文件\napp.use(express.static(\"src\"));\napp.use(express.static(__dirname));\napp.get(\"/\", (req, res) => {\n    return res.render(\"index\", {\n        userName: \"\",\n        token: \"\",\n        hasLogin: false\n    })\n})\n//连接mongodb，db为该工程的数据库名\nmongoose.connect(\"mongodb://localhost/db\", function(err, db) {\n    if(err) {\n        console.log(\"连接失败\");\n        process.exit(1);\n    }\n    else {\n        console.log(\"连接成功\")\n    }\n})\n\napp.listen(\"8888\", () => {\n    console.log(\"server created!\");\n})\n```\n\n运行`node app`：\n\n![](https://upload-images.jianshu.io/upload_images/1495096-aaec7a6377726802.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我们还可以使用`supervisor`实现代码更新功能，只需要`npm i supervisor -g`然后用`supervisor app`代替`node app`即可。每次代码有了变更都会自动帮你重启服务器。\n\n#### 环境搭建结束\n\n到此步为止，环境搭建已经结束，项目也可以成功跑起来了，只不过没有任何内容，剩下的就是一步一步写业务。\n\n### 四、CSRF防范\n在写业务之前，简单实现了一下`CSRF的`防范，我的做法是管理员登录成功后，后端直接在页面中生成一个`script`标签，标签内包含了简单的登录信息和`token`。之后管理员每一次与后端交互都要发送这个`token`，由后端校验`token`，如果不一致，则直接返回，不再执行正常逻辑。\n\n#### 模板引擎\n由后端生成`script`标签，让我最先想到了模板引擎，因此我使用了`ejs`来实现该功能，这也是为什么用户页面和管理员页面的后缀不是`html`的原因。我们看一下`admin.html`里面的内容吧：\n\n![](https://upload-images.jianshu.io/upload_images/1495096-3d14255409e4604c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n当管理员登录成功后，就可以全局访问`userInfo`了。\n\n下面我们看一下登录的逻辑：\n```\nconst login = module.exports = (req, res) => {\n    const {userName, password} = req.body;\n    const session = req.session;\n    //用户名和密码正确，保存session，并告知前端登录成功\n    if(userName === \"admin\" && password === \"admin\") {\n        if(session) {\n            if(session.user) {\n                res.json({\n                    retCode: -1,\n                    retMsg: \"您已登录过了\"\n                })\n            }\n            else {\n                session.user = {\n                    userName,\n                    password\n                }\n                res.json({\n                    retCode: 0,\n                    retInfo: {}\n                })\n            }\n        }\n        else {\n            res.json({\n                retCode: -1,\n                retMsg: \"\"\n            })\n        }\n    }\n    else {\n        res.json({\n            retCode: -1,\n            retMsg: \"用户名或密码错误\"\n        })\n    }\n}\n```\n\n#### 中间件\n管理员登录成功后，`session`里面保存了登录信息，那么下一步就是生成`token`并将其和用户登录信息渲染到页面中。在`asp.net`和`java`中有一个叫做`拦截器`的东西，它的作用就是拦截所有请求，包括ajax请求和资源请求，在其中做一些操作然后控制请求是否继续往下执行，就像一个管道一样。在`express`中，`中间件`的作用和其是一样的，我们看一下中间件的代码：\n```\n//app,js\nconst interceptor = require(\"./controller/interceptorCtrl\");\napp.use((req, res, next) => {\n    interceptor(req, res, next);\n})\n\n//interceptorCtrl.js\nconst jwt = require('jsonwebtoken');\n\nconst interceptor = module.exports = (req, res, next) => {\n    let url = req.path;\n    //页面请求，判断session是否有值，如果有的话则生成token并将userName、token、hasLogin渲染到页面上\n    if(!!(~url.indexOf(\".html\"))) {\n        url = url.replace(/\\//g, \"\");\n        const page = url.split(\".\")[0];\n        //将用户登录信息和token返回给前台\n        if(req.session.user) {\n            const token = jwt.sign({name: \"token\"}, \"node-health\", {expiresIn: 600});\n            const { userName } = req.session.user;\n            res.render(page, {\n                userName,\n                token,\n                hasLogin: true\n            })\n        }\n        else {\n            res.render(page, {\n                userName: \"\",\n                token: \"\",\n                hasLogin: false\n            })\n        }\n        next();\n    }\n    //如果是ajax请求并且请求接口来自管理员，那么校验请求参数中的token是否正确，不正确的话则直接返回retCode 500\n    else if(!!(~url.indexOf(\"/api/admin\"))) {\n        let token = \"\";\n        const method = req.method.toLowerCase();\n        if(method == \"get\") {\n            token = req.query.token;\n        }\n        else {\n            token = req.body.token;\n        }\n        jwt.verify(token, \"node-health\", function (err, decoded) {\n            if (!err) {\n                if(decoded.name !== \"token\") {\n                    return res.json({\n                        retCode: 500,\n                        retMsg: \"csrf\"\n                    })\n                }\n                else {\n                    next();\n                }\n            }\n            else {\n                return res.json({\n                    retCode: 500,\n                    retMsg: \"csrf\"\n                })\n            }\n        })\n    }\n    else {\n        next();\n    }\n}\n```\n\n功能很简单：如果是页面请求，则判断session是否有用户信息：如果有的话说明登录成功了，生成`token`并将其和登录信息渲染到页面上；如果没有登录信息，则渲染空值即可，执行`next()`让请求继续往下执行。如果是ajax请求，获取请求参数中的`token`并解密，校验值的正确性：如果不正确，则直接返回错误信息，请求不再往下执行；如果正确，执行`next()`让请求继续往下执行。\n\n### 五、写一个Ajax吧\n我们以管理员获取所有分类为例，看一下前后端分别是如何实现的。\n\n#### 前端\n\n组件在`componentDidMount`阶段发起`server`的请求 --> 等待后端返回数据 --> 发起`action` --> `reducer`中保存数据 --> 更新视图\n\n由于用户和管理员都需要获取分类列表，因此我将分类的`server`和`action`都划分到了用户模块。\n\n##### src/components/admin/center.js\n```\nimport { bindActionCreators } from \"redux\";\nimport { connect } from \"react-redux\";\nimport * as server from \"../../server/adminServer\";\n...\ncomponentDidMount() {\n    this.props.actions.getCategory({token: userInfo.token}, null, res => message.error(res.retMsg));\n}\nrender() {\n    return (\n        <div>\n            ...\n            {/*渲染分类列表*/}\n            {this.props.category.map((item, index) => (<div>...</div>)}\n        </div>\n    )\n}\n...\n// 将actions绑定到props上\nconst mapDispatchToProps = (dispatch) => ({\n    actions: bindActionCreators(server, dispatch)\n});\n//将state绑定到props上\nconst mapStateToProps = (state) => ({\n    category: state.adminReducer.category\n});\n\nexport default connect(mapStateToProps, mapDispatchToProps)(AdminCenter);\n```\n\n##### src/server/adminServer.js\n这里使用到了`redux-thunk`。\n```\n...\nimport * as action from \"../action/userAction\";\nexport function getCategory(successBK, errorBK) {\n    return (dispatch, getState) => {\n        return getData(url.SERVER_ADMIN + url.GET_CATEGORY).then(res => {\n            if(res.retCode == 0) {\n                dispatch(action.getCategory(res.retInfo));\n                successBK && successBK(res.retInfo);\n            }\n            else {\n                errorBK && errorBK(res);\n            }\n        }, e => console.log(e))\n        .catch(e => console.log(e))\n    }\n}\n```\n\n##### src/actionType/userAction.js\n```\n...\nexport function getCategory(category) {\n    return {\n        type: types.GET_CATEGORY,\n        category\n    }\n}\n```\n\n##### src/reducer/adminReducer.js\n```\n...\nconst defaultState = {\n    category: []\n}\nconst adminReducer = (state = defaultState, action) => {\n    switch(action.type) {\n        case types.GET_CATEGORY: \n            return Object.assign({}, state, {\n                category: action.category\n            })\n        default:\n            return state;\n    }\n}\nexport default adminReducer;\n```\n\n#### 后端\n`中间件`拦截请求，校验`token`并继续执行 --> 路由映射 --> 转发给控制层 --> 处理并返回数据\n\n##### app.js\n```\n...\nconst adminRouter = require(\"./router/adminRouter\");\n\napp.use(\"/api/admin\", adminRouter);\n...\n```\n\n##### router/adminRouter.js\n```\nconst express = require(\"express\");\nconst category= require(\"../controller/user/category\");\nconst router = express.Router();\n...\n//调用控制层\nrouter.get(\"/getCategory\", (req, res) => {\n    category.getCategory(req, res);\n})\n\nmodule.exports = router;\n```\n\n##### controller/user/category\n```\nconst models = require(\"../../model/index\");\n//从数据库中读取分类并返回给前端\nconst getCategory = (req, res) => {\n    models.Category.find((err, result) => {\n        if(err) {\n            res.json({\n                retCode: -1,\n                retMsg: \"mongoose error\"\n            })\n        }\n        res.json({\n            retCode: 0,\n            retInfo: result\n        })\n    })\n}\n\nmodule.exports = {\n    getCategory\n}\n```\n\n![](https://upload-images.jianshu.io/upload_images/1495096-7d39ad4d5ba42568.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 六、图片上传\n管理员添加和修改食物信息时需要上传图片。如果只是练习的话，可以将图片保存到本地并将图片绝对路径保存到数据库中。但是，我们来个更加贴切真实项目的吧，将图片保存到图片服务器中~\n\n我们将图片保存到`七牛云`存储系统中，你需要先注册个账号，官网地址在[这里](https://www.qiniu.com/)。\n\n在管理控制台 --> 对象存储 --> 内容管理中可以看到已经存储的图片：\n\n![](https://upload-images.jianshu.io/upload_images/1495096-624c106bf6b7671d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n下一步要做的就是前端上传图片发送给后端，后端上传到七牛云并将图片链接保存到数据库。\n\n#### 前端上传图片\n使用`<input type=\"file\" />`实现图片选择。默认样式比较丑，因此我自己重写了样式：\n\n![](https://upload-images.jianshu.io/upload_images/1495096-f78df8643831c1e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后要做的就是使用`formData`对象将图片信息发送给后端。\n```\nconst fileEle = this.refs.file;\nconst file = fileEle.files[0];\nlet formData = new FormData();\nformData.append(\"imgUrl\", file);\nformData.append(\"name\", this.state.name);\n...\nthis.props.actions.addFood(formData);\n```\n\n#### 后端接收图片\n后端接收图片需要用到`multiparty`插件，你只需要`npm i multiparty -S`即可。\n\n```\n//controller/admin/foodHandler.js\nconst multiparty = require(\"multiparty\");\n\nconst addFood = (req, res) => {\n    const form = new multiparty.Form();\n    form.parse(req, (err, fields, files) => {\n        console.log(fields);\n        console.log(files);\n    })\n}\n```\n\n![](https://upload-images.jianshu.io/upload_images/1495096-673e21339f1f2449.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 上传到七牛云\n我们需要使用到七牛云的`node sdk`，`npm i qiniu -S`。使用文档请访问[Node.js SDK](https://developer.qiniu.com/kodo/sdk/1289/nodejs)。\n\n我们首先要做一些配置：\n```\n//七牛云图片域名\nconst domain = \"http://ox6gixp8f.bkt.clouddn.com/\";\n//两个密钥，可以在七牛云的个人中心的密钥管理中找到\nconst accessKey = \"qVavZs09FHGxYJdaC-1ZDQeqJVbJQAbyOPnBGu5g\";\nconst secretKey = \"I4Y4lXRbZz4zL7t2llASK5Lg8Eo5zKEna_uTCPfe\";\n//定义鉴权对象mac\nconst mac = new qiniu.auth.digest.Mac(accessKey, secretKey);\n//空间名，请和你的七牛云空间名保持一致\nconst bucket = \"sunnychuan\";\n//上传的凭证\nconst options = {\n    scope: bucket,\n    expires: 7200\n};\n//生成凭证\nconst putPolicy = new qiniu.rs.PutPolicy(options);\n//生成token\nconst uploadToken = putPolicy.uploadToken(mac);\n//初始化config\nconst config = new qiniu.conf.Config();\n// 空间对应的机房\nconfig.zone = qiniu.zone.Zone_z0;\n//七牛云图片上传对象\nconst formUploader = new qiniu.form_up.FormUploader(config);\nconst putExtra = new qiniu.form_up.PutExtra();\n```\n接下来要做的就是将图片信息上传到七牛云：\n```\nconst file = files.imgUrl[0];\nconst localFile = file.path;\nconst temp = file.path.split(\"\\\\\");\nconst key = temp[temp.length - 1]; //xxx.jpg\n\nformUploader.putFile(uploadToken, key, localFile, putExtra, (respErr, respBody, respInfo) => {\n    if(respInfo.statusCode == 200) {\n        const imgUrl = domain + respBody.key;\n        //保存到数据库即可\n    }\n})\n```\n\n我们可以在七牛云上看到已经上传的图片：\n\n![](https://upload-images.jianshu.io/upload_images/1495096-fe9e12a4ba7b95c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n### 结束语\n本项目从功能上来说只是简单的`CRUD`，但用到的技术比较多，也是为了给自己做一个整体技术栈的实战，后期还可以考虑添加分页和排序功能。\n\n如果你觉得对你有帮助，欢迎`star`~，如果有任何疑问或bug，也欢迎提供`issue`。\n\n","tags":["node"],"categories":["技术博客"]},{"title":"拇指琴之卡农第一部分","url":"/2018/07/17/2018-07-17-life-cannon/","content":"卡农整首曲子下来还是很有难度的，主要是谱子实在太难背了。。。还需要多多练习呀~ 先奉上第一段的视频吧~ \n<center>\n    <video id=\"video\" controls=\"\" preload=\"none\">\n        <source id=\"mp4\" src=\"{{site.baseurl}}/img/mescal/cannon.mp4\"></source>\n    </video>\n</center>\n\n","tags":["拇指琴"],"categories":["生活"]},{"title":"拇指琴之往后余生","url":"/2018/07/17/2018-07-31-life-the-rest-of-life/","content":"拇指琴的声音很清脆，搭配上马良的伴奏，很有美感~ 往后余生，四季冷暖是你。\n<center>\n    <video id=\"video\" controls=\"\" preload=\"none\">\n        <source id=\"mp4\" src=\"{{site.baseurl}}/img/mescal/the-rest-of-life.mp4\"></source>\n    </video>\n</center>\n\n","tags":["拇指琴"],"categories":["生活"]},{"title":"基于vue封装的轻量级下拉刷新组件","url":"/2018/07/04/2018-07-04-technology-vpull-refresh/","content":"#### 如何使用\n将项目中的`src/components/pullRefresh.vue`和`src/img`拷贝到你的工程内。如层级发生改变，你需要手动修改`pullRefresh.vue`中的图片链接地址。\n#### API\n属性 | 说明 | 类型 | 默认值\n----|-----|------|------\nrefreshing | 是否处于刷新状态| boolean | `false`\nonRefresh | 刷新的回调函数 | function | `() => {}`\ntipHeight | 刷新提示信息的高度 | string | `50px`\npullHeight| 滚动区域高度 | string | `100vh`\npullTip | 下拉时的提示文字 | string | `下拉即可刷新`\nrefreshTip | 刷新中的提示文字 | string | `正在刷新`\n\n#### 示例\n\n```\n<template>\n<pull-refresh :refreshing=\"isRefreshing\" :on-refresh=\"onRefresh\" pull-height=\"400px\">\n  <div class=\"list\">\n    <p v-for=\"n in 20\">{{n}}</p>\n  </div>\n</pull-refresh>\n</template>\n\n<script>\nimport pullRefresh from \"@/components/pullRefresh.vue\";\n  export default  {\n    name: 'Example',\n    data() {\n      return {\n        isRefreshing: false\n      }\n    },\n    methods: {\n      onRefresh() {\n        //刷新前需要先手动将设为true，否则pull-refresh不会监测到状态变化\n        this.isRefreshing = true;\n        setTimeout(() => {\n          this.isRefreshing = false;\n        }, 5000)\n      }\n    },\n    components: { pullRefresh }\n}\n</script>\n\n<style scoped>\n.list {\n  background-color: white;\n}\np {\n  margin: 0;\n}\n</style>\n```\n\n#### 手动刷新\n```\n<pull-refresh :refreshing=\"isRefreshing\">\n  <div class=\"list\">\n    <p v-for=\"n in 20\">{{n}}</p>\n    <button @tap=\"refresh\">手动刷新</button>\n  </div>\n</pull-refresh>\n\n<script>\n//在methods中添加如下代码\ntap() {\n  this.isRefreshing = true;\n  setTimeout(() => {\n    this.isRefreshing = false;\n  }, 5000)\n}\n</script>\n```\n","tags":["vue"],"categories":["技术博客"]},{"title":"x-ui","url":"/2018/04/21/2018-04-21-technology-x-ui/","content":"跨平台的移动端ui组件库\n\n### 介绍\nx-ui是基于react native和react开发出的跨android、ios和h5的三端ui组件库。\n\n### 如何使用\n#### 起步\n`git clone https://github.com/mescalchuan/x-ui.git`，将`common`和`component`放入项目中，之后您需要根据自身需求做出相应配置。\n\n#### H5\n##### 移动端适配\n`x-ui` h5端统一使用了阿里的`flexible.js`适配方案，版本为`0.3.4`，通过`<script src=\"http://g.tbcdn.cn/mtb/lib-flexible/0.3.4/??flexible_css.js,flexible.js\"></script>`将其链接到`header`标签中。`flexible.js`以iphone6为参考单位：在`375 x 667`dp， `dpr`为2的情况下，页面的缩放比例为0.5，html的`font-size`为75px。以100px为例，最终计算出的rem值为`(100*2/75)rem`。对于字体而言，建议以`[data-dpr]`属性来区分不同dpr下的文本字号大小：\n```\ndiv { font-size: 16px; } \n[data-dpr=\"2\"] div { font-size: 32px; } \n[data-dpr=\"3\"] div { font-size: 48px; }\n```\n\n##### 字体\n请将`fonts`文件夹放入您的项目中，并在css文件中配置：\n```\n@font-face\n{\n    font-family: Ionicons;\n    src: url('fonts/Ionicons.ttf');\n    font-style: italic; //required\n}\n```\n\n#### React Native\n##### Android\n请将`fonts`文件夹放入`android/app/src/main/assets/`中。\n##### IOS\n请将`fonts`文件夹托至xcode中，勾选`Add to targets`和`Create groups`。在`Info.plist`中新建`Fonts provided by application`属性，item设置为`Ionicons`。\n\n### 组件\n* #### ActionSheet\n底部弹出框，多用于分享、图片下载等操作。\n\n属性 | 说明 | 类型 | 默认值\n----|-----|------|------\ntitle | 标题 | string | `\"\"`\noptions | 按钮配置项 | array | `[]`\nshowCancelButton | 是否显示取消按钮 | boolean | `true`\ncancelButtonTitle | “取消”按钮的标题 | string | `\"取消\"`\ncancelButtonColor | “取消”按钮的颜色 | string | `\"#108EE9\"`\nbackdropPressToClose | 点击遮罩层时是否关闭ActionSheet | boolean | `false`\nonPress | ActionSheet点击事件，会返回每个options的索引 | function | `() => {}`\nshow() `static` | 外部打开actionsheet | function | |\nhide()  `static` | 外部关闭actionsheet | function | |\n```\n<ActionSheet\n  ref = {o => this.ActionSheet = o}\n  options = {[\n    'option1',\n    <span className = {'header-text text-blue-color'} >{'option2'}</span>,\n    <span className = {'intro-title main-text-color'} >{'删除'}</span>\n  ]}\n  title = {'自定义组件'}\n  backdropPressToClose = {true}\n  cancelButtonColor = {'#ff4f4f'}\n  onPress = {() => alert(index)}\n/>\n<button onClick = {() => this.ActionSheet.show()} >open</button>\n```\n\n```\n<ActionSheet\n  ref = {o => this.ActionSheet = o}\n  options = {[\n    'option1',\n    <Text style = {{color: '#108EE9', fontSize: 18}} >{'option2'}</Text>,\n    <Text style = {{color: '#ff4f4f', fontSize: 20}} >{'删除'}</Text>\n  ]}\n  title = {'自定义组件'}\n/>\n<Button title = {'open'} onPress = {() => this.ActionSheet.show()} />\n```\n\n* #### Badge\n角标，用于消息数量的显示以及一般的小型徽标。当含有子组件时，角标悬浮在自组件右上角，num生效，text失效；当不含自组件时，角标作为单独的徽标，text失效，num生效。\n\n属性 | 说明 | 类型 | 默认值\n----|-----|------|------\nnum | 角标数字 | number | `0`\ndefaultBackColor | 角标背景色 | string | `\"#ff4f4f\"`\nfontColor | 角标文字颜色 | string | `\"white\"`\ntext | 自定义角标内容 | string | `\"\"`\nstyle | 自定义角标样式 | object | `{}`\n\n```\nconst boxContainer = <div className = {'badge-box'} ></div>\n<Badge num = {1} style = {{marginRight: '0.8rem'}} >{boxContainer}</Badge>\n<Badge text = {'券'} defaultBackColor = {'#f19736'} />\n```\n\n```\nconst containerBox = {\n  width: 30,\n  height: 30,\n  backgroundColor: 'gray'\n}\n<Badge num = {1} style = {{marginRight: 30}} >\n  <View style = {containerBox} ></View>\n</Badge>\n```\n\n* #### Button\n按钮，支持块级、内联级、全填充、边框填充、大小等设置。\n\n`import Button, {BUTTON_SIZE, BUTTON_TYPE} from './component/button'`\n\n属性 | 说明 | 类型 | 默认值\n----|-----|------|------\nactiveOpacity `rn only` | 按钮点击时的按钮透明度 | number | `0.6`\ninline | 是否是行内按钮 | boolean | `false`\nbuttonColor | 按钮背景色 | string | `\"#ff4f4f\"`\nbuttonStyle | 自定义按钮样式 | object | `{}`\nsize | 按钮大小 | BUTTON_SIZE| `BUTTON_SIZE.MIDDLE`\ntype | 按钮类型 | BUTTON_TYPE| `BUTTON_TYPE.FILL`\ntextStyle | 文本样式 | object | `{}`\ndisabled | 是否禁用 | boolean | `false`\nloading `rn only` | 是否显示loading圈 | boolean | `false`\nloadingColor `rn only` | loading圈的颜色 | string | `\"white\"`\nicon | 按钮小图标, 如果loading为true，则icon无效 | element | `null`\nonPress | 触摸函数 | function | `() => {}` \n\n```\n<Button\n  inline\n  size = {BUTTON_SIZE.SMALL}\n  type = {BUTTON_TYPE.GHOST}\n  icon = {<Icon name = {'ios-close-circle'} color = {'white'} size = {14} />}\n  onPress = {() => alert('button')}\n>small</Button>\n```\n\n* #### Card\n卡片视图，用于详细信息的展示。\n\n属性 | 说明 | 类型 | 默认值\n----|-----|------|------\n`Card` cardStyle | 卡片基本样式 | object | `{}`\n`Card.Header` headerStyle | 头部样式 | object | `{}`\n`Card.Body` bodyStyle | 主要内容体样式 | object | `{}`\n`Card.Footer` footerStyle | 底部样式 | object | `{}`\n\n```\n<Card cardStyle = {margin15Ver} >\n  <Card.Header>\n    <p className = {'intro-text'} >这是一个标题</p>\n  </Card.Header>\n  <Card.Body>\n    <p className = {'intro-text'} >这是一个同时使用到了Card.Header、Card.Body、Card.Footer的卡片。</p>\n  </Card.Body>\n  <Card.Footer>\n    <p className = {'intro-text'} >底部左侧</p>\n    <p className = {'intro-text'} >底部右侧</p>\n  </Card.Footer>\n</Card>\n```\n\n```\n<Card cardStyle = {{marginHorizontal: 15, borderRadius: 8}} >\n  <Card.Header>\n    <Text style = {{color: '#333333', fontSize: 16, fontWeight: 'bold'}} >标题</Text>\n  </Card.Header>\n  <Card.Body>\n    <Text style = {{color: '#666666'}} >考虑到卡片的样式因需求的不同而不同，我们没有规定卡片所嵌套的组件的样式，这需要您自己定制。</Text>\n  </Card.Body>\n  <Card.Footer footerStyle = {{paddingVertical: 10}} >\n    <Text style = {{color: '#68b1ed'}} >喜欢</Text>\n    <Text style = {{color: '#68b1ed'}} >更多</Text>\n  </Card.Footer>\n</Card>\n```\n\n* #### Carousel\n轮播图，用于图片切换展示。\n\n属性 | 说明 | 类型 | 默认值\n----|-----|------|------\nindex | 当前索引值 | number | `0`\nwidth | 轮播图宽度 `required` | number `rn`, any `h5` | `null`\nheight | 轮播图高度 `required` | number `rn`, any `h5` | `null`\nautoPlay | 是否自动播放 | boolean | `true`\nautoPlayTimeout | 自动播放时每张图片的切换时间 | number | `3000 => ms`\nshowDot | 是否展示圆点 | boolean | `true`\ndotColor | 圆点的颜色 | string | `\"#666666\"`\nactiveDotColor | 激活圆点的颜色 | string | `\"#68b1ed\"`\ndotWidth | 圆点的宽度 | number | `10 => rn`, `20 => h5(px)`\ndotBottomOffset `rn only` | 原点距离轮播图底部的距离，默认为圆点的宽度 | number | `dotWidth`\nonIndexChanged | 索引值发生改变时的回调 | function | `() => {}`\ncarouselStyle `rn only` | 轮播图样式 | object | `{}` \n\n```\nconst imgArr = ['./image/1.jpg', './image/2.jpg', './image/3.jpg', './image/4.jpg'];\n<Carousel\n  width = { '100vw' }\n  height = { '30vh' }\n  autoPlay = {false} \n  index = {2} \n  onIndexChanged = {(index) => console.log(index)}\n>\n  {\n    imgArr && imgArr.map((url, index) =>\n      <img key = { index } src = { url }/>)\n  }\n</Carousel>\n```\n\n```\nconst style = {width: utils.window.width, height: 200}\n<Carousel \n  carouselStyle = {{marginBottom: 20}} \n  width = {utils.window.width} \n  height = {200} \n  autoPlay = {false} \n  index = {2} \n  onIndexChanged = {(index) => console.log(index)}\n>\n  <Image source = {require('../../image/scenery.jpg')} style = {style } />\n  <Image source = {require('../../image/carousel1.jpg')} style = {style} />\n  <Image source = {require('../../image/swiper-bk.jpg')} style = {style} />\n  <Image source = {require('../../image/carousel2.jpg')} style = {style} />\n</Carousel>\n```\n\n * #### Checkbox\n多选框\n\n属性 | 说明 | 类型 | 默认值\n----|-----|------|------\n`Checkbox.Group` defaultValue | 默认value | any | `null`\n`Checkbox.Group` value | value（受控）| any | `null`\n`Checkbox.Group` onChange | 多选框勾选值发生改变时的回调，将会返回新的勾选值 | function | `() => {}`\n`Checkbox.Group` disabled | 是否禁用 | boolean | `false`\n`Checkbox.Group` groupStyle | 自定义group容器样式 | object | `{}`\nid `h5 only` | checkbox id `required` | string | `null`\nvalue | checkbox value | any | `null`\nchecked | 是否勾选（受控）| boolean | `null`\ncheckboxColor `rn only` | 颜色 | string | `#ff4f4f`\ncheckboxStyle | 自定义样式 | object | `{}`\ntextStyle | 自定义文本样式 | object | `{}`\ndisabled | 是否禁用 | boolean | `false`\nonChange | 每次点击时的回调，返回勾选状态（bool） | function | `() => {}`\n\n```\n<Checkbox.Group value = {this.state.value} onChange = {value => this.setState({value})} >\n  <Checkbox id = {'checkbox_1'} value = {'A'} >A</Checkbox>\n  <Checkbox id = {'checkbox_2'} value = {'B'} >B</Checkbox>\n  <Checkbox id = {'checkbox_3'} value = {'C'} >C</Checkbox>\n</Checkbox.Group>\n```\n\n```\n<Checkbox.Group defaultValue = {['B']} >\n  <Checkbox value = {'A'} >A</Checkbox>\n  <Checkbox value = {'B'} >B</Checkbox>\n  <Checkbox value = {'C'} >C</Checkbox>\n</Checkbox.Group>\n```\n\n* #### Collapse\n折叠面板，信息的展开与收起。\n\n属性 | 说明 | 类型 | 默认值\n----|-----|------|------\nactivityKey | 当前激活项 | string, number | `\"\"`\nonChange | 任意一个折叠面板的折叠状态发生改变时的回调，返回当前激活项（string or JSON.stringify(stringArray)） | function | `() => {}`\naccordion | 是否开启手风琴模式 | boolean | `false`\nstyle | 自定义样式 | object | `{}`\n`Collapse.Panel` key | id | string, number | `\"\"`\n`Collapse.Panel` title | 标题 | string, number | `\"\"`\n\n```\n<Collapse\n  accordion = {true}\n  onChange = {(activeKey) => activeKey && alert(activeKey)}\n  style = {{marginBottom: '0.4rem'}}\n  activeKey = {'panel2'}\n>\n  <Collapse.Panel title = {'标题1'} panelKey = {'panel1'} >\n    <p className = {'panel-margin'} >这是一个含有回调函数的手风琴模式的面板子组件</p>\n  </Collapse.Panel>\n  <Collapse.Panel title = {'标题2'} panelKey = {'panel2'} >\n    <p className = {'panel-margin'} >这是一个含有回调函数的手风琴模式的面板子组件</p>\n  </Collapse.Panel>\n  <Collapse.Panel title = {'标题3'} panelKey = {'panel3'} >\n    <p className = {'panel-margin'} >这是一个含有回调函数的手风琴模式的面板子组件</p>\n  </Collapse.Panel>\n</Collapse>\n```\n\n```\n<Collapse\n  accordion = {true}\n  onChange = {(activeKey) => activeKey && ToastAndroid.show(activeKey, ToastAndroid.SHORT)}\n  style = {{marginBottom: 20}}\n>\n  <Collapse.Panel title = {'标题1'} panelKey = {'panel1'} >\n    <Text style= {styles.panel} >这是一个含有回调函数的手风琴模式的面板子组件</Text>\n  </Collapse.Panel>\n  <Collapse.Panel title = {'标题2'} panelKey = {'panel2'} >\n    <Text style= {styles.panel} >这是一个含有回调函数的手风琴模式的面板子组件</Text>\n  </Collapse.Panel>\n  <Collapse.Panel title = {'标题3'} panelKey = {'panel3'} >\n    <Text style= {styles.panel} >这是一个含有回调函数的手风琴模式的面板子组件</Text>\n  </Collapse.Panel>\n</Collapse>\n```\n\n* #### Counter\n计数器，数字选择框。\n\n属性 | 说明 | 类型 | 默认值\n----|-----|------|------\ndefaultValue | 计数器默认值 | number | `null`\nvalue | 计数器的值 | number | `null`\nmaxValue | 最大值 | number | `99`\nminValue | 最小值 | number | `0`\nstepNum | 跨度值 | number | `1`\nbtnWidth `rn only` | 按钮宽度 | number | `35`\ncontainerHeight `rn only` | 总高度 | number | `30`\ninputWidth `rn only` | 输入框宽度 | number | `40`\nborderColor | 边框颜色 | string | `\"#d5d3d3\"`\nbtnColor | 按钮颜色 | string | `\"#eeeeee\"`\nonChange | value发生改变时的回调 | function | `() => {}`\ndisabled | 是否禁用 | boolean | `false`\ngetValue() `static` | 外部获取计数值 | function | | \n\n```\n<Counter defaultValue = {5} stepNum = {2} minValue = {1} maxValue = {9} />\n```\n\n* #### DrawerLayout\n抽屉视图，用于左右侧弹出的菜单。\n`import DrawerLayout, {DRAWER_POSITION, DRAWER_LOCK_MODE, KEYBOARD_DISMISS_MODE} from './component/drawerLayout'`\n\n属性 | 说明 | 类型 | 默认值\n----|-----|------|------\ndrawerWidth `rn only` | 抽屉宽度 | number | `200`\nrenderNavigationView | 抽屉内容 | function | `() => {}`\ndrawerPosition | 抽屉位置 | DRAWER_POSITION |`DRAWER_POSITION.LEFT`\ndrawerLockMode `rn only` | 抽屉状态 | DRAWER_LOCK_MODE | `DRAWER_LOCK_MODE.UNLOCKED`\nkeyboardDismissMode `rn only` | 键盘关闭模式 | KEYBOARD_DISMISS_MODE | `KEYBOARD_DISMISS_MODE.NONE`\nonDrawerOpen | 抽屉打开时的回调 | function | `() => {}`\nonDrawerClose | 抽屉关闭时的回调 | function | `() => {}`\nonDrawerSlide `rn only` | 抽屉滑动时的回调 | function | `() => {}`\nopenDrawer() `static` | 外部打开抽屉 | function | |\ncloseDrawer() `static` | 外部关闭抽屉 | function | |\n\n```\nconst drawerView = (\n  <div>\n    <List title = {'前往商城'} showLine />\n    <List title = {'个人中心'} showLine />\n    <List title = {'设置'} showLine />\n    <p className = {'margin-15 header-text'}>I'm in the Drawer!</p>\n  </div>\n)\n<Button \n  onPress = {() => this.drawer.openDrawer()} \n>打开右侧抽屉</Button>\n<DrawerLayout \n  drawerPosition = {DRAWER_POSITION.RIGHT} \n  renderNavigationView = {() => drawerView} \n  ref = {drawer => this.drawer = drawer} \n/>\n```\n\n```\nconst navigationView = (\n  <View style={{flex: 1, backgroundColor: '#fff'}} >\n    <List title = {'前往商城'} />\n    <List title = {'个人中心'} />\n    <List title = {'设置'} />\n    <Text style={{margin: 10, fontSize: 15, textAlign: 'left'}}>I'm in the Drawer!</Text>\n  </View>\n)\n<DrawerLayout\n  drawerWidth = {200}\n  renderNavigationView = {() => navigationView}\n  onDrawerOpen = {() => console.log('opend')}\n  onDrawerClose = {() => console.log('closed')}\n  onDrawerSlide = {() => console.log('sliding')}\n  ref = {drawer => this.Drawer = drawer}\n>\n  <View style = {styles.container} >\n    <Text style = {styles.introduction} >一个纯JavaScript实现的抽屉组件，具有和React Native的DrawerLayoutAndroid相同的api。我们舍弃了使用率较低的onDrawerStateChanged，并将所有枚举类型单独提取出来。</Text>\n    <Button buttonColor = {'#108EE9'} onPress = {() => this.Drawer.openDrawer()} >打开抽屉</Button>\n  </View>\n</DrawerLayout>\n```\n\n* #### Flex\n基于flex实现的栅格系统。\n\n属性 | 说明 | 类型 | 默认值\n----|-----|------|------\njustify | 主轴对齐方式 | string, flex-justify-conent | `\"flex-start\"`\nalign | 次轴对齐方式 | string, flex-align-items (`h5`比`rn`多了`stretch`和`baseline`) | `\"flex-start\"`\nwrap| 折行方式 | string, flex-wrap | `\"wrap\"`\nflexStyle | 容器样式 | object | `{}`\n`Flex.Item` flex | 空间分配比例 | number | `1`\n`Flex.Item` flexItemStyle | flexItem样式 | object | `{}` \n\n```\n<Flex flexStyle = {{marginBottom: '0.4rem'}} >\n  <Flex.Item>\n    <div className = {'flex-item'} style = {{backgroundColor: '#108EE9'}} >\n      <p className = {'flex-text'} >50%</p>\n    </div>\n  </Flex.Item>\n  <Flex.Item>\n    <div className = {'flex-item'} style = {{backgroundColor: '#4badf3'}} >\n      <p className = {'flex-text'} >50%</p>\n    </div>\n  </Flex.Item>\n</Flex>\n```\n\n```\n<Flex \n  justify = {'flex-end'} \n  align = {'flex-end'} \n  flexStyle = {{marginBottom: 20}} \n>\n  {\n    (function() {\n      return [1,2,3].map((item, index) => {\n        let secondViewStyle = {};\n        if(index == 1) {\n          secondViewStyle = {\n            height: 20\n          }\n        }\n        return (\n          <View \n            key = {index} \n            style = {[styles.wrapStyle, secondViewStyle, {marginLeft: 10, marginRight: 0}, {backgroundColor: '#8c62f9'}]} \n          >\n            <Text style = {styles.flexText} >修改次轴</Text>\n          </View>\n        )\n      })\n    })()\n  }\n</Flex>\n```\n\n* #### Header\n头部导航\n\n属性 | 说明 | 类型 | 默认值\n----|-----|------|------\ncontainerStyle | 容器样式 | object | `{}`\ntitle | 标题 | string | `\"\"`\ntitleStyle | 标题样式 | object | `{}`\nleftBtn | 自定义左侧按钮 | element | `null`\nrightBtn | 自定义右侧按钮 | element | `null`\n\n```\n<Header\n  title = {'导航栏'}\n  containerStyle = {{backgroundColor: '#01DD9B'}}\n  rightBtn = {<span className = {'header-text'} style = {{color: 'white'}} >更多</span>}\n/>\n```\n\n```\nconst rightBtn = (\n  <TouchableOpacity onPress = {() => alert('更多')} >\n    <Text style = {styles.more} >更多</Text>\n  </TouchableOpacity>\n)\n<Header\n  title = {'头部'}\n  leftBtn = {rightBtn}\n  containerStyle = {{backgroundColor: '#f0eded'}}\n  titleStyle = {{color: '#333333'}}\n/>\n```\n\n* #### Icon\n字体图标，基于`Ionicons`。\n\n属性 | 说明 | 类型 | 默认值\n----|-----|------|------\nname | icon名字，参考`iconMap.json` | string | `\"ios-add\"`\nsize | icon大小 | number | `15 => rn`, `30 => h5(px)`\ncolor | icon颜色 | string | `\"#666666\"`\niconStyle | 自定义icon样式 | object | `{}`\n\n```\n<Icon name = {'ios-analytics'} size = {20} color = {'#ff4f4f'} />\n```\n\n* #### List\n列表，用于数据列表展示、基本内容呈现。\n\n属性 | 说明 | 类型 | 默认值\n----|-----|------|------\nlistStyle | list最顶层的样式，一般用于margin和padding | object | `{}`\ncontentStyle `rn only` | list内容样式，不包括按钮 | object | `{}`\ntitle | 列表标题 | string | `\"\"`\ntitleStyle | 自定义标题样式 | object | `{}`\nrightContent | list右侧内容 | element | `null`\nrightIcon | 右侧icon | element | `<Image/> => rn`, `<img/> => h5`\nshowRightIcon | 是否显示右侧icon | boolean | `false`\nleftContent | list左侧内容 | element | `null`\nleftContentFlex | 左侧内容的垂直布局 | string, flex-justify-content | `\"center\"`\nrightContentFlex | 右侧内容的垂直布局 | string, flex-justify-content | `\"center\"`\nonPress | list点击时的回调 | function | `() => {}`\ntouchOpacity `rn only` | list点击时的透明度 | number | `1`\nshowLine | 是否显示底部分割线 | boolean | `false`\nlineMargin | 底部分割线的margin | number | `15 => rn`, `30 => h5(px)`\nbtnConfig `rn only` | 左滑显示出的按钮, `//[], {text, color, fontSize, backgroundColor, width}` | array | `[]`\n\n```\n<List\n  title = {'控制左右内容的对齐方式'}\n  showRightIcon = {false}\n  leftContent = {contacts}\n  rightContent = {<span className = {'list-third-text'} >12:00</span>}\n  rightContentFlex = {'flex-start'}\n>\n  <p className = {'list-second-text'} >左侧内容居中于List</p>\n  <p className = {'list-third-text'} >右侧内容上对齐于List</p>\n</List>\n```\n\n```\n<List\n  title = {'灰色置顶'}\n  listStyle = {{marginBottom: 20}}\n  showRightIcon = {false}\n  btnConfig = {[{\n    text: '置顶',\n    width: 60,\n    backgroundColor: 'gray',\n    onPress: () => alert('您点击了置顶按钮')\n  }, {\n    text: '提醒',\n    width: 60,\n    backgroundColor: '#c4af00',\n    onPress: () => alert('您点击了提醒按钮')\n  }, {\n    text: '删除',\n    width: 60,\n    onPress: () => alert('您点击了删除按钮')\n  }]}\n>\n  <Text style = {{fontSize: 15}} >黄色提醒</Text>\n  <Text style = {{fontSize: 14}} >红色删除</Text>\n</List>\n```\n\n* #### Pagination\n分页控件\n\n属性 | 说明 | 类型 | 默认值\n----|-----|------|------\ndefaultPageNum | 默认页码数 | number | `null`\npageNum | 页码数 | number | `null`\npageTotal | 总页数 | number | `1`\nprevious | 上一页按钮文字 | string | `\"上一页\"`\nnext | 下一页按钮文字 | stirng | `\"下一页\"`\nhidePage | 隐藏数字 | boolean | `false`\nhideButton | 隐藏按钮 | boolean | `false`\ndisabled | 禁用分页按钮 | boolean | `false`\nonChange | 页码改变时的回调 | function | `() => {}`\nactivePageColor | 当前页码的颜色 | string | `\"#ff4f4f\"`\npageColor | 数字的颜色(/pageTotal) | string | `\"#333333\"`\npreviousBtnStyle | 上一页按钮样式 | object | `{}`\nnextBtnStyle | 下一页按钮样式 | object | `{}`\npreviousTextStyle | 上一页文字样式 | object | `{}`\nnextTextStyle | 下一页文字样式 | object | `{}`\n\n```\n<Pagination\n  pageTotal = {5}\n  previous = {'prev'}\n  next = {'next'}\n  activePageColor = {'#108EE9'}\n  pageColor = {'#333333'}\n  previousBtnStyle = {{backgroundColor: '#108EE9', borderWidth: 0}}\n  previousTextStyle = {{color: 'white'}}\n  nextBtnStyle = {{backgroundColor: '#108EE9', borderWidth: 0}}\n  nextTextStyle = {{color: 'white'}}\n/>\n```\n\n* #### Radio\n单选框\n\n属性 | 说明 | 类型 | 默认值\n----|-----|------|------\n`Radio.Group` defaultValue | 默认值 | any | `null`\n`Radio.Group` value | value --> 受控 | any | `null`\n`Radio.Group` onChange | group value更改时的回调，返回当前value | function | `() => {}`\n`Radio.Group` disabled | 是否禁用 | boolean | `false`\n`Radio.Group` groupStyle | 自定义group容器样式 | object | `{}`\nid `h5 only` | radio id `required` | string | `null`\nvalue | radio value | any | `null`\nchecked | 是否勾选（受控）| boolean | `null`\nradioColor `rn only` | radio颜色 | string | `\"#ff4f4f\"`\nradioStyle | 自定义radio样式 | object | `{}`\ntextStyle | 自定义文本样式 | object | `{}`\ndisabled | 是否禁用 | boolean | `false`\n\n```\n<Radio.Group value = {this.state.value} onChange = {value => this.setState({value})} >\n  <Radio id = {'radio_1'} value = {'A'} >A</Radio>\n  <Radio id = {'radio_2'} value = {'B'} >B</Radio>\n  <Radio id = {'radio_3'} value = {'C'} >C</Radio>\n</Radio.Group>\n```\n\n```\n<Radio.Group defaultValue = {'B'} >\n  <Radio value = {'A'} >A</Radio>\n  <Radio value = {'B'} >B</Radio>\n  <Radio value = {'C'} >C</Radio>\n</Radio.Group>\n```\n\n* #### Search\n搜索框，一般放置于头部导航下方，用于搜索信息，支持弹出层。\n\n属性 | 说明 | 类型 | 默认值\n----|-----|------|------\ndefaultValue | 默认值 | string | `\"\"`\nvalue | value（受控）| string | `\"\"`\nplaceholder | 提示信息 | string | `\"搜索\"`\ncancelText | “取消”按钮的文本 | string | `\"取消\"`\ntouchableOpacity `rn only` | 触摸透明度 | number | `0.8`\nonChange | 搜索框内容发生改变时触发 | function | `() => {}`\nonSubmit | 提交时触发 | function | `() => {}`\nonFocus | 聚焦时触发 | function | `() => {}`\nonBlur | 失焦时触发 | function | `() => {}`\nonCancel | 点击“取消”时触发 | function | `() => {}`\nshowModal | 是否启动modal模式 | boolean | `false`\nshowCancelButton | 是否始终显示“取消”按钮 | boolean | `false`\ndisabled | 是否禁用 | boolean | `false`\nmodalComponent | 如果开启了modal模式，使用该属性定义Modal组件内的子元素 | element | `null`\n\n```\n<Search\n  defaultValue = {'test'}\n  placeholder = {'输入任何内容'}\n  showCancelButton\n/>\n```\n\n```\n<Search\n  defaultValue = {'test'}\n  value = {this.state.value}\n  onChange = {(value) => {this.setState({value})}}\n  showModal\n  modalComponent = {\n    <View style = {styles.component} >\n      <Text style = {{fontSize: 16}} >您自己的组件</Text>\n    </View>\n  }\n/>\n```\n\n* #### Slider\n滑块\n\n属性 | 说明 | 类型 | 默认值\n----|-----|------|------\nwidth | 滑块宽度 | number | `150 => rn`, `300 => h5(px)`\nprogress | 当前value值 | number | `0`\nminValue | 滑块最小值 | number | `0`\nmaxValue | 滑块最大值 | number | `100`\nbarColor | 轨道颜色 | string | `\"#d5d3d3\"`\nballColor | 圆形按钮颜色 | string | `\"#108ee9\"`\ncrossColor | 已经过的轨道的颜色 | string | `\"#108ee9\"`\ndisabled | 是否禁用 | boolean | `false`\nonChange | value发生改变时的回调 | function | `() => {}`\ngetValue() `static` | 外部获取滑块值 | function | |\n\n```\n<Slider\n  progress = {1}\n  minValue = {1}\n  maxValue = {99}\n  onChange = {val => this.setState({value2: val})}\n/>\n```\n\n* #### Switch\n开关，用于设置两个相互斥的选项。\n\n属性 | 说明 | 类型 | 默认值\n----|-----|------|------\nvalue | 开关值（true or false）| boolean | `false`\nonValueChange | value发生改变时的回调 | function | `() => {}`\nonTintColor | 开关打开时背景色 | string | `\"#00b247\"`\ntintColor | 开关关闭时背景色 | string | `\"white\"`\nthumbTintColor | 圆形按钮背景色 | string | `\"white\"`\nonTintBorderColor | 开关打开时边框颜色 | string | `\"#eeeeee\"`\ntintBorderColor | 开关关闭时边框颜色 | string | `\"#eeeeee\"`\nthumbBorderColor | 圆形按钮边框颜色 | string | `\"#eeeeee\"`\ndisabled | 是否禁用 | boolean | `false`\n\n```\n<Switch\n  tintColor = {'gray'}\n  onTintColor = {'#f75b25'}\n  thumbTintColor = {'#68b1ed'}\n  tintBorderColor = {'gray'}\n  onTintBorderColor = {'#f75b25'}\n  thumbBorderColor = {'#68b1ed'}\n  value = {this.state.value}\n  onValueChange = {value => this.setState({value: value})}\n/>\n```\n\n* #### Tabbar\n选项卡，位于页面最底部，用于页面切换。\n\n属性`rn` | 说明 | 类型 | 默认值\n----|-----|------|------\ntabBarStyle | 自定义tabBar容器样式 | object | `{}`\ntabBarShadowStyle | 自定义tabBar最上方的分割线的样式 | object | `{}`\nhidesTabTouch | 指定为true时，touchableOpacity将变为1 | boolean | `false`\n`TabBar.Item` selected | 是否被选中 | boolean | `false`\n`TabBar.Item` titleStyle | 自定义默认（未选中）时的文本样式 | object | `{}`\n`TabBar.Item` selectedTitleStyle | 自定义选中时的文本样式 | object | `{}`\n`TabBar.Item` title | 标题 | string | `\"\"`\n`TabBar.Item` name | 指定一个key | string | `\"\"`\n`TabBar.Item` tabStyle | 自定义每个TabBar.Item的容器样式 | object | `{}`\n`TabBar.Item` icon | 未选中时的图标 | element | `null`\n`TabBar.Item` selectedIcon | 选中时的图标 | element | `null`\n`TabBar.Item` changeTab | 切换时触发，返回选中状态的item的name（key）| function | `() => {}`\n\n属性`h5` | 说明 | 类型 | 默认值\n----|-----|------|------\ntabBarStyle | 自定义tabBar容器样式 | object | `{}`\ntabBarShadowStyle | 自定义tabBar最上方的分割线的样式 | object | `{}`\nitems | tabbarItems | array | `[]`\ncomponents | tabbarComponents | array | `[]`\nselectedTab | 选中的tab的name | string | `\"\"`\n`TabBar.Item` titleStyle | 自定义默认（未选中）时的文本样式 | object | `{}`\n`TabBar.Item` selectedTitleStyle | 自定义选中时的文本样式 | object | `{}`\n`TabBar.Item` title | 标题 | string | `\"\"`\n`TabBar.Item` name | 指定一个key | string | `\"\"`\n`TabBar.Item` tabStyle | 自定义每个TabBar.Item的容器样式 | object | `{}`\n`TabBar.Item` icon | 未选中时的图标 | element | `null`\n`TabBar.Item` selectedIcon | 选中时的图标 | element | `null`\n`TabBar.Item` changeTab | 切换时触发，返回选中状态的item的name（key）| function | `() => {}`\n\n```\nimport {Home, Active, Timer, Settings} from './container';\n\nconstructor(props) {\n  super(props);\n  this.state = {\n    currentTab: 'active'\n  };\n}\nsetTabItem(name, title, icon) {\n  return (\n    <TabBar.Item \n      changeTab = {(tab) => this.setState({currentTab: tab})}\n      title = {title}\n      name = {name}\n      icon = {<Icon name = {icon} size = {25} color = {'#666666'} />}\n      selectedIcon = {<Icon name = {icon} size = {25} color = {'#ff4f4f'} />}\n    />\n  )\n}\nsetTabComponent(name, component) {\n  return (\n    <TabBar.Component name = {name} >\n      {component}\n    </TabBar.Component>\n  )\n}\nrenderTabItem() {\n  let tabItems = [];\n  tabItems.push(this.setTabItem('home', '首页', 'ios-home'));\n  tabItems.push(this.setTabItem('active', '激活', 'ios-bulb'));\n  tabItems.push(this.setTabItem('timer', '定时器', 'ios-clock'));\n  tabItems.push(this.setTabItem('settings', '设置', 'ios-settings'));\n  return tabItems;\n}\nrenderTabComponents() {\n  let tabComponents = [];\n  tabComponents.push(this.setTabComponent('home', <Home/>));\n  tabComponents.push(this.setTabComponent('active', <Active/>));\n  tabComponents.push(this.setTabComponent('timer', <Timer/>));\n  tabComponents.push(this.setTabComponent('settings', <Settings/>));\n  return tabComponents;\n}\nrender() {\n  return (\n    <TabBar \n      selectedTab = {this.state.currentTab} \n      items = {this.renderTabItem()} \n      components = {this.renderTabComponents()} \n    />\n  )\n}\n```\n\n```\nimport {Home, Active, Timer, Settings} from './container';\nconstructor(props) {\n  super(props);\n  this.state = {\n    currentTab: 'active'\n  }\n}\nrenderTabItem(name, title, icon, component) {\n  return (\n    <TabBar.Item\n      selected = {this.state.currentTab === name}\n      changeTab = {(tab) => this.setState({currentTab: tab})}\n      title = {title}\n      name = {name}\n      icon = {<Icon name = {icon} size = {25} color = {'#666666'} />}\n      selectedIcon = {<Icon name = {icon} size = {25} color = {'#ff4f4f'} />}\n      titleStyle = {{fontSize: 12, color: '#666666'}}\n      selectedTitleStyle = {{fontSize: 12}}\n    >\n      {component}\n    </TabBar.Item>\n  )\n}\nrender() {\n  return (\n    <TabBar hidesTabTouch>\n      {this.renderTabItem('home', '首页', 'ios-home', <Home/>)}\n      {this.renderTabItem('active', '激活', 'ios-bulb', <Active/>)}\n      {this.renderTabItem('timer', '定时器', 'ios-clock', <Timer/>)}\n      {this.renderTabItem('settings', '设置', 'ios-settings', <Settings/>)}\n    </TabBar>\n  )\n}\n```\n\n* #### Toast\n小型提示框\n\n配置项 | 说明 | 类型\n----|-----|------\ncontent | 提示信息 | string\nduration | 持续时间 | number (ms)\nmask | 是否使用遮罩层，默认为true，使用遮罩层的话在toast显示期间无法对屏幕进行任何操作 | boolean\n\n```\n<Button onPress = {() => this.toast.show({\n  content: '取消遮罩层',\n  mask: false\n})} >取消遮罩层</Button>\n<Toast ref = {toast => this.toast = toast} />\n```\n\n##### 全局提示\n```\n//根js\ncomponentDidMount() {\n  window.addEventListener('showToast', e => {\n    this.rootToast.show(window.toastConfig);\n  })\n}\nrender() {\n  return (\n    <div>\n      <Router history={hashHistory} routes = {routerConfig} />\n        <Toast ref = {toast => this.rootToast = toast} />\n    </div>\n  )\n}\n\n//子组件\n<Button onPress = {() => {\n  window.toastConfig = {\n    content: '全局提示',\n    mask: false\n  }\n  window.dispatchEvent(new Event('showToast'))\n}} >全局提示</Button>\n```\n\n```\n//根js\ncomponentDidMount() {\n  DeviceEventEmitter.addListener('showToast', (config) => {\n    this.rootToast.show(config);\n  })\n}\nrender() {\n  return (\n    <View style = {{flex: 1}} >\n      <Navigator />\n      <Toast ref = {toast => this.rootToast = toast} />\n    </View>\n  );\n}\n\n//子组件\n<Button \n  onPress = {() => DeviceEventEmitter.emit('showToast', {\n    content: '全局提示',\n    mask: false\n})} >全局提示</Button>\n```","tags":["react-native"],"categories":["技术博客"]},{"title":"一个能够快速构建AngularJS多页项目的轻量级脚手架","url":"/2018/02/25/2018-02-25-technology-angular-m-cli/","content":"\n![](https://upload-images.jianshu.io/upload_images/1495096-ae70d8dd97a57e89.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 一款基于`webpack`的快速构建`angular1`的多页应用构建方案\n\n### [文档地址](https://mescalchuan.github.io/angular-m-cli)\n\n#### 使用angular-m-cli，您可以做到\n* 快速构建项目原型\n* 自动生成新页面并完成相关配置（包括入口文件、css、`index.html`）\n* 利用本地服务器完成开发\n* 使用`mock`进行接口测试，实现前后端分离\n* 一键删除指定页面和相关配置\n* 一键打包\n\n#### 核心技术\n* `co` 自动执行`Generator`\n* `co-prompt` co的命令行实现，同步获取用户输入\n* `commander` 命令行创建与解析的工具\n* `download-git-repo` github源码下载\n* `ejs` 模板渲染\n\n\n### 参考\n[vue-cli](https://github.com/vuejs/vue-cli)、[教你从零开始搭建一款前端脚手架工具](https://segmentfault.com/a/1190000006190814)\n\n","tags":["angular"],"categories":["技术博客"]},{"title":"优雅地配置Atom","url":"/2018/01/27/2018-01-27-technology-atom/","content":"从最初的sublime text，到webstorm，后来又转战visual studio code，直到现在的atom，就个人使用体验来看是越来越舒适的。之前一直在使用sublime text和webstorm，后来尝试了一把vs code，发现其插件安装非常方便，主题也很优雅，于是就将vs code作为常用开发工具。最近vs code经常出现智能提示消失的现象，特别是当代码中有语法错误之后，除非重启，否则就跟用记事本没什么区别，可能是插件本身的问题，等过一阵子再尝试。昨天花了整整一个下午的时间体验atom，它的插件安装和vs code一样方便，社区也很活跃，下面是我最终的配置结果：\n\n![atom](http://upload-images.jianshu.io/upload_images/1495096-fc5ef474d3f88148.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 基本配置\n前往[atom官网](https://atom.io/)下载最新版本：\n\n![](http://upload-images.jianshu.io/upload_images/1495096-ea76ed55986ebc76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n安装成功后，根据个人喜好做一些基本配置。我个人喜欢将tab缩进长度设置为4，这样代码看起来不是那么紧凑。\n\n![](http://upload-images.jianshu.io/upload_images/1495096-d7e6b3cb4148f94b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nAtom默认是不显示缩进线的，你需要手动勾选`show indent guide`。\n![](http://upload-images.jianshu.io/upload_images/1495096-4f1c57ac4c68c700.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 主题\n\n推荐`atom material`和`seti-ui`，但我个人更喜欢`atom material`这种扁平化的风格，编辑器嘛就使用默认的`one dark`，两者搭配起来使用效果更好。直接在`settings -> install`中输入关键字，然后点击安装即可。\n\n![主题安装](http://upload-images.jianshu.io/upload_images/1495096-bccc9a2f38837ecf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n安装成功后，在`settings -> themes -> ui theme`中选择`atom msterial`即可切换主题。\n\n#### 插件\n这里罗列了一些经常用到的插件，参考了kompasim的[atom-plugins](https://github.com/kompasim)。插件的安装方法与主题相同，每个插件的具体配置都在github上有详细说明。\n1. `atom-beautify` 格式化代码\n2. `atom-ternjs` es5、es6、node、jQuery等代码自动补全\n3. `pigments` 颜色代码片段的背景色以该颜色显示，效果如图：\n\n![](http://upload-images.jianshu.io/upload_images/1495096-93b2ab8711d4b38c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n4. `minimap` 实现sublime text的代码预览，效果如图：\n![](http://upload-images.jianshu.io/upload_images/1495096-fee436966feb56e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n5. `autocomplete-modules` 模块自动补全。这个在es6开发中经常用到，会智能显示当前路径下的模块，搭配`autocomplete-paths`一起使用，效果如图：\n![](http://upload-images.jianshu.io/upload_images/1495096-15eb37a6942a6aeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n6. `autocomplete-paths` 路径智能提示，它的默认项目最大文件数为2000，当超过这个数量时插件不再运行。目前的前端项目2000+的文件已经再正常不过了（包含了node_modules），可以在`autocomplete-paths`的设置中修改：\n\n![](http://upload-images.jianshu.io/upload_images/1495096-13a941a8e8e13508.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n不过并不建议修改该默认值，如果你的电脑性能不是很高的话重启atom后会十分卡顿。\n7. `file-icons` 为文件添加小图标，效果如图：\n\n![](http://upload-images.jianshu.io/upload_images/1495096-13776b2743800479.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n8. `atom-html-preview` 预览html页面\n9. `js-hyperclick` ctrl+鼠标左键跳转到变量定义处，它依赖于其他插件，当出现提示框时点击确认让其自动安装即可。\n10. `linter` 基本的错误检查，推荐在其之上安装更精准的错误检查插件\n11. `linter-eslint` js错误检查，比`linter-jshint`更容易配置和实用。推荐将.eslintrc放到`c:\\Users\\用户名\\`下，在`linter-eslint`的设置中配置路径：\n\n![](http://upload-images.jianshu.io/upload_images/1495096-fcd1def768721329.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\neslint的配置请参考[官方文档](https://eslint.org/docs/user-guide/configuring)\n```\n//.eslintrc\n{\n    \"env\": {\n        \"browser\": true,\n        \"node\": true,\n        \"commonjs\": true,\n        \"es6\": true\n    },\n    \"parserOptions\": {\n        \"ecmaVersion\": 6,\n        \"sourceType\": \"module\",\n        \"ecmaFeatures\": {\n            \"jsx\": true\n        }\n    }\n}\n```\n![](http://upload-images.jianshu.io/upload_images/1495096-9592016bab9c6911.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n目前的配置并不支持es7语法：\n\n![](http://upload-images.jianshu.io/upload_images/1495096-497ea35c4bb739c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n需要在.eslintrc中添加`\"parser\": \"babel-eslint\",`，然后linter-eslint会抛出如下错误：\n\n![](http://upload-images.jianshu.io/upload_images/1495096-06fc9f9d9c9e2ca8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n我们点开错误信息，进入到linter-eslint文件中，安装`babel-eslint`：\n\n![](http://upload-images.jianshu.io/upload_images/1495096-3c2efcabae8b0959.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n```\ncd /c/Users/qinchuana/.atom/packages/linter-eslint\nnpm install babel-eslint --save\n```\n重启atom，一切ok了。\n12. `terminal-plus` 内嵌控制台\n13. `highlight-selected` 高亮显示相同的单词，效果如图：\n\n![](http://upload-images.jianshu.io/upload_images/1495096-75229de63e42469b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n14. `docblockr` 快速编写注释文档\n15. `language-babel` jsx自动编译\n16. `language-javascript-jsx` 支持jsx语法\n17. `emmet-jsx-css-modules` jsx中的css emmet\n18. `atom-react-autocomplete` react的智能提示\n19. `atom-react-es6-snippets` 快速生成es6写法的react片段\n20. `react-native-snippets` 快速生成react native片段\n21. `atom-react-native-style` 快速书写rn样式，效果如图：\n\n![](http://upload-images.jianshu.io/upload_images/1495096-0c39980283a721ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n22. `activate-power-mode` 一个特效插件，当连击数达到一定值后每敲一次键盘都会有颗粒特效和震动，效果如图：\n![](http://upload-images.jianshu.io/upload_images/1495096-4f4c7fecf351593a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n\n\n\n\n\n","tags":["工具"],"categories":["技术博客"]},{"title":"React Native之巧用TextInput","url":"/2018/01/19/2018-01-19-technology-react-native-textinput/","content":"近日使用rn开发电商app遇到一个再简单不过的需求：买家申请退款，填写申请单，其中有一个多行文本输入框用于填写退款理由，如图所示：\n\n![](http://upload-images.jianshu.io/upload_images/1495096-969a3263e2eafdf3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n看似简单的需求，然而用rn开发还是会遇到问题。\n#### 页面搭建\n两个View和一个TextInput足矣，外层View白色背景色，内层View提供边框。如果你在安卓环境下运行项目会发现TextInput下面有一条黑线，将underlineColorAndroid设置为true既可解决。同时，将paddingVertical设置为0解决TextInput文字不垂直居中的问题。\n```\n<View style = {styles.container} >\n    <View style = {styles.inputContainer} >\n        <TextInput\n            placeholder = {'输入退款说明'} \n            placeholderTextColor = {'#BBBBBB'}\n            underlineColorAndroid = {'transparent'} \n            style = {{paddingVertical: 0, paddingLeft: 5, fontSize: 16}}\n         />\n    </View>\n</View>\n```\n运行结果如图所示：\n\n![](http://upload-images.jianshu.io/upload_images/1495096-3f58b17349a4ee10.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 问题\n我们更改一下TextInput的背景色，发现此时TextInput的高度为一行文字的高度，并且，当输入较长的内容后，文字仍然排成一行而不是单起一行。\n\n![](http://upload-images.jianshu.io/upload_images/1495096-cdb26eaea5123f2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n既然这样，我们将TextInput的高度设置为其外层的容器高度，并指定其为多行文本：\n```\n<TextInput\n    placeholder = {'输入退款说明'} \n    placeholderTextColor = {'#bbbbbb'}\n    underlineColorAndroid = {'transparent'} \n    multiline\n    style = {{paddingVertical: 0, paddingLeft: 5, fontSize: 16, height: 105}}\n/>\n```\n效果如图：\n\n![](http://upload-images.jianshu.io/upload_images/1495096-c621fd4b77fe63b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n现在，整个内层容器都是文本框了，但是文本框的内容却是垂直居中的，很明显与设计不符。通过翻阅rn的源码发现，TextInput是原生代码实现的，前端将justifyContent设置为flex-start仍然不能解决该问题。产品经理也肯定不会接受这种解决方案。\n\n#### 解决方案\n思路就是动态修改TextInput的高度，其高度由内容行数决定，这样就能保证内容始终是紧靠顶端的。然后，为TextInput的外层容器绑定onPress事件，当点击容器时自动聚焦TextInput，形成“整个容器都是TextInput”的假象。\n\n```\nconstructor(props) {\n    super(props);\n    this.state = {\n        height: 30\n    }\n}\n\ncauculateHeight(e) {\n    const height = e.nativeEvent.contentSize.height > 30 ? e.nativeEvent.contentSize.height : this.state.height;\n    this.setState({height});\n}\n```\n```\n<TouchableOpacity \n    activeOpacity = {1}\n    style = {styles.inputContainer} \n    onPress = {() => this.TextInput.focus()} \n>\n    <TextInput\n        placeholder = {'输入退款说明'} \n        placeholderTextColor = {'#bbbbbb'}\n        underlineColorAndroid = {'transparent'} \n        multiline\n        ref = {textInput => this.TextInput = textInput}\n        onContentSizeChange = {e => this.cauculateHeight(e)}\n        style = {[{paddingVertical: 0, paddingLeft: 5, fontSize: 16}], {height: this.state.height}]}\n    />\n</TouchableOpacity>\n```\n\n![](http://upload-images.jianshu.io/upload_images/1495096-451e5da7219e5ce1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![](http://upload-images.jianshu.io/upload_images/1495096-7997458637d44c77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n当内容超过容器高度后，超出的部分被隐藏了，给TextInput添加maxHeight样式解决该问题（maxHeight值为容器高度）。\n```\n<TextInput\n    ...\n    style = {[{paddingVertical: 0, paddingLeft: 5, fontSize: 16, maxHeight: 105}], {height: this.state.height}]}\n/>\n```\n\n![](http://upload-images.jianshu.io/upload_images/1495096-5ac6da860fe48aba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n\n\n\n\n\n\n\n","tags":["react-native"],"categories":["技术博客"]},{"title":"近日使用React Native Linking踩过的坑","url":"/2017/11/20/2017-11-20-technology-react-native-linking/","content":"使用react native（以下简称rn）开发移动端app已经有四个月的时间了（包括第一个月的上手），感谢rn，让前端开发人员也能够开发原生的app。前几天遇到一个需求：打开第三方的支付应用并监听返回的结果。听上去这个需求并不难，然而使用rn来实现就会遇到大大小小的坑。为了能让其他开发人员少走弯路，在这里总结一下。\n### 使用Linking\n写这篇博客的原因还有一个：网上有很多关于Linking的博客，然而有深度的文章少之又少，大部分都是简单介绍了Linking的使用方法（我搜过好几篇文章内容和代码都是一样的）。\n\n#### Linking基本使用方法\n这里我建议去rn的[中文官网](http://reactnative.cn/)学习，那里讲解的十分详细。通过查看文档我们了解到，Linking使用url来唤起系统应用或链接。其实Linking还可以唤起其他的app，前提条件是你的手机上已经安装了它。\n\n#### 唤起其他app\n使用Linking唤起其他app比较简单，只需要简单的两个步骤：1.检查该app能否被唤起，也就是检查该app是否已安装成功；2.唤起并传递参数。\n\nLinking提供了canOpenURL这个方法，用来检测某个url是否可以打开：\n```\nLinking.canOpenURL('appName://').then(canOpen=>{\n    ...\n})\n```\n\n使用Linking打开app也比较简单，调用openURL方法即可：\n```\nLinking.openURL('appName://?params');\n```\n\n为了方便演示，我准备了两个app：lka和lkb。这两个应用功能比较简单，只含有一个button，点击的时候唤起另外一个app，同时传递参数。被唤起的app获取参数并alert出来。\n\n![](http://upload-images.jianshu.io/upload_images/1495096-6d2696551a740f1e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![](http://upload-images.jianshu.io/upload_images/1495096-3c1bf87a4b4e04a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n现在，我需要在lka里唤起lkb，代码是这样的：\n```\nLinking.canOpenURL('lkb://').then(canOpen=>{\n    if(canOpen){\n        Linking.openURL('lkb://?orderId=1');\n    }\n});\n```\n\n你如果直接点击button的话是肯定不会跳转的，因为canOpen是false。可能有些人会问：我明明已经安装了lkb，为什么会打不开？这里就要说到scheme了，我们可以把它理解为一个app的标识，当url的协议部分与scheme匹配时，app就会被打开。\n\n我们需要在AndroidManifest.xml里进行相关的配置：\n```\n<activity\n    android:name=\".MainActivity\"\n/*add  -->*/ android:launchMode=\"singleTask\"\n    android:label=\"@string/app_name\"\n    android:configChanges=\"keyboard|keyboardHidden|orientation|screenSize\"\n    android:windowSoftInputMode=\"stateAlwaysHidden|adjustPan\"\n>\n    <intent-filter>\n        <action android:name=\"android.intent.action.MAIN\" />\n        <category android:name=\"android.intent.category.LAUNCHER\" />\n        <action android:name=\"android.intent.action.DOWNLOAD_COMPLETE\"/>    \n    </intent-filter>\n/*add start*/\n    <intent-filter>\n        <action android:name=\"android.intent.action.VIEW\" />\n        <category android:name=\"android.intent.category.DEFAULT\" />\n        <category android:name=\"android.intent.category.BROWSABLE\" />\n        <data android:scheme=\"lka\" />\n    </intent-filter>\n/*add end*/\n</activity>\n```\n我们添加了两块代码：launchMode和intent-filter。关于launchMode可以参考[这篇文章](http://blog.csdn.net/liuhe688/article/details/6754323/)学习。我们新添加了一个intent-filter，关于intent-filter的相关知识可以自行上网搜索。Intent-filter顾名思义就是意图过滤器，它就像过滤器一样筛选每次传过来的url，只要有符合条件的url就会执行intent-filter里面的相关操作。\n\n在本代码中，我们在intent-filter里配置了scheme，只要url的协议为lka就会打开lka app。请注意，不要把两个intent-filter合并到一起，虽然你的app能够正常运行，但是你将会在手机上找不到app的图标。\n\n再次点击openLkb按钮，唤起成功。\n\n![](http://upload-images.jianshu.io/upload_images/1495096-074f7cd65f5672d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\n//lkb\ncomponentDidMount(){\n    Linking.getInitialURL().then(url=>{\n        alert(url);\n    })\n}\n```\n#### 开始踩坑\n现在，lka已经能够成功唤起lkb了，并且传递的参数在lkb里也能接收到，那么反过来也是一样的？现在我们增加一下需求，只要lka从后台运行到了前台或者首次打开均弹出url。\n\n实现起来比较简单，我们需要监听app的运行状态，需要用到AppState：\n```\n//lka\nimport {\n    Linking,\n    AppState\n} from 'react-native'\n...\ncomponentDidMount(){\n    AppState.addEventListener('change',(appState)=>{\n        if(appState=='active'){\n\t        Linking.getInitialURL().then(url=>{\n\t            alert('stateChange'+url)\t\t\n\t        })\n\t    }\n    })\n    Linking.getInitialURL().then(url=>{\n\t    alert('didmount:'+url);\n    })\n}\n```\n```\n//lkb\nopenLka(){\n    Linking.canOpenURL('lka://').then(res=>{\n        if(res){\n            Linking.openURL('lka://?name=sunnychuan&age=23');\n        }\n    });\n}\n```\n\n同样的，为lka配置好AndroidManifest.xml，把scheme配置成lka。我们首先把lka关掉，然后在lkb里唤起它，结果如下：\n\n!](http://upload-images.jianshu.io/upload_images/1495096-99ec56ea6225f449.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我们通过任务管理切回到lkb，然后点击按钮再次唤起lka，你得到的结果还是正确的：\n\n![](http://upload-images.jianshu.io/upload_images/1495096-8b80d0e126a79227.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n先别急着高兴，我们把lka和lkb都关掉，重新打开lka，你将得到“didmount:null”的结果。这是当然的，因为你是自己打开的嘛。\n\n然后，我们通过lka唤起lkb，再通过lkb唤起lka，你得到的结果如下：\n\n![](http://upload-images.jianshu.io/upload_images/1495096-3b6ae4208b0c8614.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n发现问题没有？你可以多尝试几次，最终会发现一个规律：`AppState.addEventListener`里面获取的url的值永远与`componentDidMount`里直接获取的url的值相同。只要首次获取的是null，那么以后永远都是null；只要首次获取的是有值的，那么以后永远都是有值的。\n\n我们看一下Linking的源码吧：\n```\n//node_modules/react-native/ReactAndroid/src/main/java/com/facebook/react/modules/intent/IntentModule.java\n...\n@ReactMethod\npublic void getInitialURL(Promise promise) {\n    try {\n        Activity currentActivity = getCurrentActivity();\n        String initialURL = null;\n        if (currentActivity != null) {\n            Intent intent = currentActivity.getIntent();\n            String action = intent.getAction();\n            Uri uri = intent.getData();\n            if (Intent.ACTION_VIEW.equals(action) && uri != null) {\n                initialURL = uri.toString();\n            }\n        }\n        promise.resolve(initialURL);\n    } catch (Exception e) {\n        promise.reject(new JSApplicationIllegalArgumentException(\n        \"Could not get the initial URL : \" + e.getMessage()));\n      }\n}\n```\n每一次调用getInitialURL，android端都会获取当前的activity，并且返回activity对象里面的data值（uri）。\n\n我们可以把`AppState.addEventListener`里面获取的url称为脏数据。通过上网翻阅相关资料后我发现，原生的android跳转其实是activity之间的跳转。现在回过头来看一下我们的xml，只有一个activity。你可以尝试一下把activity拆成两个，其中一个专门用来配置scheme，运行结果并不符合我们的预期。\n\n原因是什么呢？这是因为react native只配置了一个activity，整个应用都是在这个activity里运行的。当lka尚未启动，由lkb唤起时，lka的activity会执行`onCreate`生命周期钩子，初始化intent，此时你将会得到全新的url：null。当lka已经运行在后台，由lkb唤起时，lka的activity不会执行`onCreate`方法，你得到的url还是旧值：null。\n\n解决方案参考了[这篇文章](http://blog.csdn.net/langtuteng136/article/details/44812143)，在android/app/src/main/java/com/lka/MainActivity.java的最下面添加：\n```\n@Override\npublic void onNewIntent(Intent intent){\n    super.onNewIntent(intent);\n    setIntent(intent);\n}\n```\n\n重新打包之后（每次修改android文件夹里面的东西后都需要重新打包才能生效），我们再尝试一下：1.关掉lka和lkb；2.打开lka，你会收到null值；3.唤起lkb；4.由lkb唤起lka。你得到的结果如下：\n\n![](http://upload-images.jianshu.io/upload_images/1495096-5845a4bd1d79f007.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n结果与我们的预期相符。\n \n#### 另一个问题\n\n其实这里还有一个潜在的问题。同样的，通过lkb唤起lka，你将接收到正确的参数“lka://?name=sunnychuan&age=23”。然后，我们手动将lka运行在后台，然后重新让它运行在前台（不通过lkb唤起），你得到的值依旧是“lka://?name=sunnychuan&age=23”。\n\n![](http://upload-images.jianshu.io/upload_images/1495096-9672a81807011a27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![](http://upload-images.jianshu.io/upload_images/1495096-69af5e5627a24df4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![](http://upload-images.jianshu.io/upload_images/1495096-7700b392b795e363.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n从代码上来看，这个结果是正确的，因为没有人更改activity的url，所以值一直没有改变；从需求上来看，这个结果是不正确的。我们假设lka在监听函数里获取url的参数，如果url有参数就跳转到支付成功页面。现在，只要lka由后台运行到前台都会跳转到支付成功页面（没准真的有用户喜欢来回切换应用）。这样显然是不合理的，我们期望的是：只有lka是由lkb唤起的（无论lka已经运行在后台还是尚未启动），才会跳转到支付成功页面。\n\n我的思路是，在`getInitialURL.then`里，首先将activity的intent重置成默认值，这需要我们自己封装android方法，我们先看一下封装后的代码：\n```\n//lka\nimport {\n    Linking,\n    AppState,\n    NativeModules\n} from 'react-native'\n...\ncomponentDidMount(){\n    AppState.addEventListener('change',(appState)=>{\n        if(appState=='active'){\n\t        Linking.getInitialURL().then(url=>{\n                NativeModules.LinkingCustom.resetURL().then(()=>{\n                    alert('stateChange'+url)\n                });\t\t\n\t        })\n\t    }\n    })\n    Linking.getInitialURL().then(url=>{\n\t    NativeModules.LinkingCustom.resetURL().then(()=>{\n            alert('didmount'+url)\n        });\t\n    })\n}\n```\n\n下面我们来为lka封装一下这个方法，如果你是安卓工程师，这点操作就是小儿科；如果你是前端工程师，并且对安卓不了解，跟着我一步一步写，很简单。\n\n#### CustomLinking\n首先，我们需要在与MainActivity.java同级的目录下新建一个java文件，导入必要的java包：\n```\n//android/app/src/main/java/com/lka/LinkingCustom.java\npackage com.lka;\nimport android.app.Activity;\nimport android.content.ComponentName;\nimport android.content.Intent;\nimport android.net.Uri;\nimport com.facebook.react.bridge.JSApplicationIllegalArgumentException;\nimport com.facebook.react.bridge.Promise;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.bridge.ReactContextBaseJavaModule;\nimport com.facebook.react.bridge.ReactMethod;\nimport com.facebook.react.module.annotations.ReactModule;\n```\n\n其次，创建CustomLinking类，你需要继承ReactContextBaseJavaModule类，并实现getName函数。这里的getName函数是必须的，返回值就是你在js端通过NativeModules拿到的模块名\"LinkingCustom\"一致：\n```\npublic class LinkingCustom extends ReactContextBaseJavaModule {\n    public LinkingCustom(ReactApplicationContext reactContext) {\n        super(reactContext);\n    }\n    @Override\n    public String getName() {\n        return \"LinkingCustom\";\n    }\n}\n```\n\n然后，我们实现重置intent的函数，将其命名为resetURL：\n```\n...\n@Override\npublic String getName() {\n    return \"LinkingCustom\";\n}\n//必须添加@ReactMethod关键字才能在js侧被调用\n@ReactMethod\n//不可以直接将结果return，因为js侧是异步获取结果的，这里将结果返回成promise，\npublic void resetURL(Promise promise) {\n    try {\n        Activity currentActivity = getCurrentActivity();\n        if (currentActivity != null) {\n            Intent intent = new Intent(Intent.ACTION_MAIN);\n            currentActivity.setIntent(intent);\n        }\n        promise.resolve(true);\n    } catch (Exception e) {\n        promise.reject(new JSApplicationIllegalArgumentException(\"Could not reset URL\"));\n      }\n}\n```\n#### LinkingCustomReactPackage\n我们在同级下新建LinkingCustomReactPackage.java文件，用来注册模块：\n```\n//android/app/src/main/java/com/lka/LinkingCustomReactPackage.java\npackage com.coomarts;\nimport com.facebook.react.ReactPackage;\nimport com.facebook.react.bridge.JavaScriptModule;\nimport com.facebook.react.bridge.NativeModule;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.uimanager.ViewManager;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n//必须实现ReactPackage接口和createNativeModules方法\npublic class LinkingCustomReactPackage implements ReactPackage{\n    @Override\n    public List<NativeModule> createNativeModules(ReactApplicationContext reactContext){\n        List<NativeModule> modules=new ArrayList<>();\n        //在这里添加你想注册的模块\n        modules.add(new LinkingCustom(reactContext));\n        return modules;\n    }\n\n    @Override\n    public List<Class<? extends JavaScriptModule>> createJSModules(){\n        return Collections.emptyList();\n    }\n\n    @Override\n    public List<ViewManager> createViewManagers(ReactApplicationContext reactContent){\n        return Collections.emptyList();\n    }\n}\n```\n\n#### 为包管理添加实例\n最后一步就是在MainApplication.java里添加实例，与添加第三方组件实例相同：\n```\n//android/app/src/main/java/com/lka/MainApplication.java\n...\n@Override\nprotected List<ReactPackage> getPackages() {\n    return Arrays.<ReactPackage>asList(\n        new SQLitePluginPackage(),\n        new MainReactPackage(),\n\t    new RNDeviceInfo(),\n\t    new VectorIconsPackage(),\n        new LinkingCustomReactPackage()\n    );\n}\n```\n\n大功告成，现在我们重复之前的步骤，看一下运行结果：\n\n![](http://upload-images.jianshu.io/upload_images/1495096-9672a81807011a27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![](http://upload-images.jianshu.io/upload_images/1495096-69af5e5627a24df4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![](http://upload-images.jianshu.io/upload_images/1495096-3b6ae4208b0c8614.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n除非lka是由lkb唤起的，否则在其他情况下运行lka得到的均是null值。\n\n","tags":["react-native"],"categories":["技术博客"]},{"title":"Webpack工程化配置","url":"/2017/11/15/2017-11-15-technology-webpack-config/","content":"本文重点讲述如何一步一步搭建webpack工程化配置，这里涉及到一些常用插件的使用以及node.js的文件操作。上篇文章介绍到，webpack配置成了两种模式，有些人喜欢将两种模式的代码放到不同的配置文件中，而我更偏爱全部集成到webpack.config.js里，因为这里有一些配置是通用的。我将代码分为三块：基本配置、开发模式配置、生产模式配置。本文建议你有一定的webpack基础，因为我不会花费大量篇幅去讲解每个loader、插件的具体用法。\n\n### 基本配置\n\n#### 核心一：多入口文件\n如果你的项目是单页应用，可能最终打包后仅仅有一个js文件、一个css文件、一个html文件。在这种情况，webpack配置起来并没有太大难度。但是一旦项目有多入口（比如多页应用），那么配置起来就比较麻烦了。\n你可以手写多个入口文件，但是这样做肯定不灵活：\n```\nentry:{\n    entry1:'xxx1.js',\n    entry2:'xxx2.js',\n    entry3:'xxx3.js',\n    ...\n}\n```\n这样的话每次你创建了新的入口文件都需要更改webpack.config.js。倒不如换一种思想：既然webpack是基于node.js的，直接规定好入口文件的目录结构然后遍历文件夹自动生成入口文件配置。\n```\nvar jsPath = path.resolve(__dirname, 'entry');\nvar files = fs.readdirSync(jsPath);\nvar entry = {};\nfiles.forEach(function(filename) {\n    var stats = fs.statSync(path.join(jsPath, filename));\n    if (stats.isDirectory()) {\n        var entryJSKey = filename + '/' + 'main.js'.split('.js')[0];\n        entry[entryJSKey] = path.join(jsPath, filename, '/' + 'main.js');\n    }\n})\n```\n```\nvar webpackConfig = {\n    entry: entry\n}\n```\n\n#### 核心二：判断当前开发环境\n我们来判断一下当前的开发环境，process.env.NODE_ENV可以获取到命令行中输入的NODE_ENV的值，我们将其定义为production：\n```\nvar DefinePlugin = webpack.DefinePlugin;\nvar isDevelopment = process.env.NODE_ENV !== 'production';\n```\n\n现在来配置一下输入路径。为了方便引用，我将输出路径定义为与入口文件同级，文件的命名与入口文件相同，后缀取决于当前的环境。\n```\nvar webpackConfig = {\n    entry: entry,\n    output: {\n        path: jsPath,\n        filename: isDevelopment ? '[name].__bundle.js' : '[name].bundle.js',\n    },\n    plugins: [\n        new webpack.DefinePlugin({\n            'process.env': {\n                NODE_ENV: JSON.stringify(process.env.NODE_ENV),\n            }\n        })\n    ]\n}\n```\n\n#### 核心三：提取公共文件\n实际项目中有很多公共的文件，将这些文件全都打包到每一个入口文件里明显不合适，因此我们使用CommonsChunkPlugin插件将公共文件和入口文件分离打包。\n```\nvar CommonsChunkPlugin = webpack.optimize.CommonsChunkPlugin;\nvar commonModule1 = path.resolve(__dirname, 'common' + '/app');\n//替换掉上面的var entry = {}\nvar entry = {\n    vendor: [commonModule1]\n}\n```\n```\nvar webpackConfig = {\n    entry: entry,\n    externals: isDevelopment ? {} : externals,\n    plugins: [\n        new CommonsChunkPlugin({\n            name: ['vendor'],\n            filename: isDevelopment ? 'vendor.__bundle.js' : 'vendor.bundle.js',\n            minChunks: Infinity\n        })\n    ]\n}\n```\n\n#### 核心四：是否需要将框架打包进来\nwebpack默认情况下会将入口文件（包括它的子模块）依赖的所有模块全部打包进来，这会导致打包后的文件十分庞大，这在开发环境下可以接受，但是生产环境下就不允许了。通常的操作是：开发环境下一次性全部打包，生产环境下框架、库等比较庞大的第三方模块不进行打包，转而使用cdn。\n```\nvar externals = {\n    'angular': 'angular',\n    'react': 'React',\n    'react-dom': 'ReactDOM'\n}\n\nvar webpackConfig = {\n    ...\n    externals: isDevelopment ? {} : externals\n}\n```\n\nExternals对象的key是框架的名字，value是你import时的变量名。举个例子，cdn上的react名字为react.js（或react.min.js），key就为\"react\"。在代码中我使用`import React from 'react'`，因此value是“React”。上述代码只是举例说明，实际上很少有项目会同时需要使用react和angular。\n\n#### 核心五：加载器\nBabel-loader是最常用的，style-loader和css-loader会根据环境的不同分别配置。你可以根据自己的项目加载更多的loader，比如url-loader、file-loader、sass-loader等。\n```\nvar webpackConfig = {\n    ...\n    module: {\n        rules: [{\n            test: /\\.js$/,\n            exclude: /node_modules/,\n            use: {\n                loader: 'babel-loader',\n                options: {\n                    presets: ['es2015', 'stage-2']\n                }\n            }\n        }]\n    }\n    ...\n}\n```\n\n### 开发环境配置\n在开发环境下我们需要：将css打包到js中；为了方便调试，需要映射打包后的代码和源代码；支持热更新；确保编译的代码没有错误，若出现错误将其记录；编译成功后自动打开页面。\n#### 创建服务器\n得益于webpack-dev-server，我们可以像node.js一样创建服务器。我们将服务器的内容定义到pages中。在服务运行后，打包后的文件就会出现在内存里，路径参考自contentBase，也就是pages。\n```\nvar htmlPath = path.resolve(__dirname, 'pages');\nvar webpackConfig = {\n    ...\n    devServer: {\n        hot: true,\n        inline: true,\n        progress: true,\n        contentBase: htmlPath,\n        port: 3000,\n        stats: {\n            colors: true\n        }\n    }\n    ...\n}\n```\n\n#### 在基本配置上添加开发环境配置\n我们先添加css模块的加载：\n```\nif (isDevelopment) {\n    var cssLoader = {\n        test: /\\.css$/,\n        use: ['style-loader', 'css-loader']\n    };\n    webpackConfig.module.rules.push(cssLoader);\n}\n```\n试想一下，在没有文件映射的情况下进行开发是多么恐怖的一件事：你的代码都被打包到了最终的js文件里，由于js混合了框架、库、css、babel转码，可以说一旦出现错误是很难定位的。为此，我们需要实现打包后的文件与源文件之间的内容映射，出现问题后可以直接定位到源文件的相应位置。\n```\nwebpackConfig.devtool = 'source-map';\n```\n我们还要支持热更新、无错保证、自动打开页面：\n```\nvar OpenBrowserPlugin = require('open-browser-webpack-plugin');\nvar HotModuleReplacementPlugin = webpack.HotModuleReplacementPlugin;\nvar NoEmitOnErrorsPlugin = webpack.NoEmitOnErrorsPlugin;\n//假设默认开启的页面位于./pages/entryPages\nwebpackConfig.plugins = webpackConfig.plugins.concat([\n    new HotModuleReplacementPlugin(),\n    new NoEmitOnErrorsPlugin(),\n    new OpenBrowserPlugin({\n        url: 'http://localhost:3000/entryPages/index.html'\n    })\n]);\n```\n\n### 生产环境配置\n在生产环境下我们需要：压缩代码；分离css和js；我们甚至可以将打包后的文件自动引入到html中。\n\n#### 分离CSS和JS\n首先是分离css和js，这里需要用到extract-text-webpack-plugin这个插件。\n```\nif (isDevelopment) {\n    ...\n}\nelse {\n    var cssLoader = {\n        test: /\\.css$/,\n        use: ExtractTextPlugin.extract({\n            fallback: 'style-loader',\n            use: 'css-loader'\n        })\n    };\n    webpackConfig.module.rules.push(cssLoader);\n    webpackConfig.plugins = webpackConfig.plugins.concat([\n        new ExtractTextPlugin('main.bundle.css', {\n            allChunks: false\n        })\n    ])\n}\n```\n\n目测文件的分离是成功了，css被提取到了js中。但是你会发现，整个输出目录里只有一个main.bundle.css，但是我不同的入口文件依赖了不同的css。一我的假设是所有import进来的css被合并到了main.bundle.css中，打开css文件后我发现，main.bundle.css里面只有最后一个入口文件导入的css，而之前的css内容全部被覆盖了。\n\n假设现在有两个入口js：\n```\n//main1.js\nimport '../css/main1.css';\n\n//main1.css\nbody: { background: red }\n```\n```\n//main2.js\nimport '../css/main2.css';\n\n//main2.css\nbody: { background: blue }\n```\n最终的main.bundle.css只有main2.css里面的内容：\n```\n//main.bundle.css\nbody: { background: blue }\n```\n\n原因是webpack在分离css的时候参考自entry的配置，从中提取css文件，依据`new ExtractTextPlugin('main.bundle.css',{...})`的第一个参数生成提取后的css文件。由于文件的名字均为main.bundle.css，文件会被依次替换，导致的结果就是提取出来的css只有最后一个entry所依赖的内容。\n\n解决方案与output相同，我们通过node.js遍历文件目录自动生成了诸如\n```\n{\n    \"page1/main\": \"./entry/page1/main.js\",\n    \"page2/main\": \"./entry/page2/main.js\",\n    \"page3/main\": \"./entry/page3/main.js\",\n}\n```\n的入口文件配置，我们可以使用[name]来获取到entry里面的key，将css命名设置为key，这样一来webpack就会根据key值在page1、2、3...的下面生成main.bundle.css了。\n```\nwebpackConfig.plugins = webpackConfig.plugins.concat([\n    new ExtractTextPlugin('[name].bundle.css', {\n        allChunks: false\n    })\n])\n```\n#### 代码压缩\n接下来我们将代码进行压缩，使用到了UglifyJsPlugin这个插件，被抽离的css文件默认情况下不会被压缩，需要额外用到optimize-css-assets-webpack-plugin这个插件。\n```\nwebpackConfig.plugins = webpackConfig.plugins.concat([\n    new UglifyJsPlugin({\n        minimize: true,\n        output: {\n            comments: false,\n        },\n        compress: {\n            warnings: false\n        }\n    }),\n    new ExtractTextPlugin('[name].bundle.css', {\n        allChunks: false\n    }),\n    new OptimizeCSSPlugin()\n]);\n```\n#### 自动引入打包后的文件\n最后，谈一下如何实现html自动引入打包后的文件。在webpack中html-webpack-plugin插件可以自动生成html页面，我们可以在为其指定模板为入口页面。为了实现生成多个html页面，需要创建多个HtmlWebpackPlugin对象，这一步我将其放在了文件操作里面。每个页面的名称与pages里面的各html相同，这样一来，生成的html页就会已原页面为模板，添加打包后的文件并覆盖原页面。\n```\nvar HtmlWebpackPlugin = require('html-webpack-plugin');\nvar jsPath = path.resolve(__dirname, 'entry');\nvar files = fs.readdirSync(jsPath);\nvar entry = {};\nfiles.forEach(function(filename) {\n    var stats = fs.statSync(path.join(jsPath, filename));\n    if (stats.isDirectory()) {\n        var entryJSKey = filename + '/' + 'main.js'.split('.js')[0];\n        entry[entryJSKey] = path.join(jsPath, filename, '/' + 'main.js');\n        if (!isDevelopment) {\n            var template = path.resolve(__dirname, 'pages', filename, 'index.html')\n            var htmlPlugin = {\n                filename: template,\n                template: template,\n                chunks: [],\n                inject: true,\n                chunksSortMode: 'manual',\n                xhtml: true,\n                showErrors: true,\n                minify: false\n            };\n            htmlPlugin.chunks = ['vendor', entryJSKey];\n            htmlPluginArr.push(new HtmlWebpackPlugin(htmlPlugin));\n            }\n    }\n})\n```\n\n上面的配置有两个关键点：1.指定每个页面需要自动引入的模块名称。默认情况下，新生成的页面会把所有打包后的文件全部引入，在多页面应用下是不可取的，我们期望每个页面只引入与本页面有关的打包文件。每个页面打包后的js名字都是相同的，但是路径是不同的，因此我们定义每个页面需要引入的js名称为`filename + '/' + 'main.js'.split('.js')[0]`，然后在chunks里指定需要加载的模块`htmlPlugin.chunks = ['vendor', entryJSKey]`。2.保证js的引入顺序。Vendor作为全局的通用代码，它需要在main之前被引入。Vendor和main应该都被引入在body的最后面。因此，我们将inject设置为true（body）,将 chunksSortMode设置为manual，确保chunks数组的顺序`['vendor', entryJSKey]`。\n\n### 运行\nWebpack的配置已经完成，现在其实就可以应用到实际项目中了。\n#### 使用Webpack命令\n我们可以通过以下三种命令执行webpack配置：\n```\n//开启服务器并执行开发模式配置\nwebpack-dev-server\n//打包开发模式配置\nNODE_ENV=development webpack\n//打包生产模式配置\nNODE_ENV=production webpack\n```\n\n下面我们来精简一下上面三个命令，使用到了cross-env这个插件`npm install cross-env`。得益于package.json，我们更改一下script字段：\n```\n//package.json\n\"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"start\": \"webpack-dev-server\",\n    \"build\": \"NODE_ENV=production webpack\",\n    \"dev\": \"NODE_ENV=development webpack\"\n  }\n```\n\n现在直接运行`npm start`，你会发现服务成功启动了。但是运行`npm run build`和`npm run dev`在windows下会报“NODE_ENV不是内部或外部命令”。为了解决该问题，cross-env就派上用场了：\n```\n//package.json\n\"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"start\": \"webpack-dev-server\",\n    \"build\": \"cross-env NODE_ENV=production webpack\",\n    \"dev\": \"cross-env NODE_ENV=development webpack\"\n  }\n```\n\n再次运行`npm run build`和`npm run dev`，打包成功。\n\n后续有时间的话可以将上述配置封装成cli，更加方便开发人员使用。\n\n#### 11月23日更新（新增mock服务）\n\nMock服务可以拦截指定的请求，返回使用者定义的数据来实现前后端分离式开发。通过写代码的方式配置mock的接口并不是很方便，因此我推荐使用mock2easy-middleware这个中间件。你可以访问[文档](https://www.npmjs.com/package/mock2easy)来查看具体的配置项。\n```\n//安装\nnpm install mock2easy-middleware --save-dev\n\n//webpack.config.js\nvar mock2easy = require('mock2easy');\n//mock服务器配置\nvar mockConfig = {\n    port: 3005,\n    lazyLoadTime: 3000,\n    database: 'mock2easy',\n    doc: 'doc',\n    ignoreField: [],\n    interfaceSuffix: '.json',\n    preferredLanguage: 'en'\n};\nmock2easy(mockConfig, function (app) {\n    app.listen(mockConfig.port, function () {\n        console.log('mockServer has started , see : localhost:' + mockConfig.port);\n    });\n});\n```\n由于当前的服务器地址为webpack-dev-server中的3000，我们需要将所有的请求都代理到mock服务器上（3005）并允许https请求。\n```\ndevServer: {\n    ...\n    proxy:{\n        '/*.json':{\n            target:'http://localhost:3005'\n            secure:false\n         }\n    }\n}\n```","tags":["webpack"],"categories":["技术博客"]},{"title":"基于Express搭建前后端分离的开发环境","url":"/2017/04/26/2017-04-26-technology-express-build/","content":"对于一个前端开发人员来说，node.js可以说是开发后端的福音。本人毕设项目使用的是asp.net（只是使用ashx来接收前端的ajax，并没有使用那些恶心的控件），通过对比发现整个项目都使用js实在是幸福。\n\n### Node.js\n关于node.js的优点就不再多说，网上一搜一大堆，项目也可以找到很多。这里主要说一下node.js关于搭建web应用这一块的缺点。\n众所周知，node.js需要自己搭建服务器，也就是说你需要自己监听一个端口并启动它\n```\nvar http=require('http');\nhttp.createServer(function(req,res) {\n    res.writeHead(200, {'Content-Type': 'text/plain'});\n    res.write(\"hello sunnychuan\");\n    res.end();\n}).listen(3000);\nconsole.log(\"server is running!\");\n```\n这里有一本电子书帮助你使用原生的node.js搭建web应用，[点击这里](http://www.nodebeginner.org/index-zh-cn.html#a-basic-http-server)\n\n不仅仅是监听端口，我们往往会根据用户输入的url从本地找到相应文件并将它写回请求\n```\nfs.exists(filePath,function(exists){\n    if(exists){\n       res.writeHead(200,{'Content-Type':contentType});\n       var stream=fs.createReadStream(filePath);\n       stream.on('error',function(){\n          res.writeHead(500,{'Content-Type':'text/html'});\n          res.end('<h1>500 Server Error</h1>');\n       });\n       stream.pipe(res);\n    }\n}\n```\n我们还会针对前端的ajax请求做路由处理\n```\n//根据不同的路径调用不同的处理程序\nvar handle={};\nhandle[\"/api/get.json\"]=requestHandlers.get;\nhandle[\"/api/post.json\"]=requestHandlers.post;\n```\n```\nfunction route(handle,pathname,req,res){\n    if(typeof handle[pathname]==='function'){\n        handle[pathname](req,res);\n    }\n    else{\n        res.writeHead(404,{'Content-Type':'text/html'});\n        res.write('<h1>404 Not Found</h1>');\n        res.end();\n    }\n}\n```\n```\nvar pathname=decodeURI(url.parse(req.url).pathname);\nif(path.extname(pathname)=='.json'){\n    route(handle,pathname,req,res);\n}\n```\n通过上面那么一折腾，原本的热情就消退了一半，这里我推荐一下express框架，官方文档在[这里](http://www.expressjs.com.cn/)\n\n### Express\n#### 安装和目录结构\n首先安装express\n```\nnpm install express --save-dev\n```\n安装express的应用生成器\n```\nnpm install express-generator -g\n```\n使用它的应用生成器可以很快建立一个项目\n```\nexpress myapp\n```\n然后进入到该文件夹下，安装所有依赖\n```\ncd myapp\nnpm install\n```\n你的目录结构长这个样子\n\n![](http://upload-images.jianshu.io/upload_images/1495096-d25565cc3ad97c09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nbin是启动项，在bin/www里面你可以修改端口号\nnode_modules用来存放npm安装的模块\npublic里面用来存放资源\nroutes是路由控制，存放了所有的处理程序\nviews是视图文件，相当于html页，在routes中会使用类似\n```\nrouter.get('/', function(req, res, next) {\n  res.render('index', { title: 'Express' });\n});\n```\n这样的代码来替换模板引擎里的内容，有点像java的.jsp文件和asp.net的.asp文件\napp.js用来配置express，你可以在这里进行路由分配和错误处理并按需加载中间件\n\n#### 启动项目\n```\nnpm start\n```\n\n![](http://upload-images.jianshu.io/upload_images/1495096-4d651e6318d58b6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 修改代码\n作为前端开发的你，也许会厌恶由后端直接将数据渲染在页面上（至少我是这样），我们通常使用ajax来进行前后端交互并自行处理后端的数据，因此整个views文件就可以直接delete掉了。\n\nstep1 更改目录结构\n把public更名为client，新建server文件夹并把routes和app.js放到里面（views直接删除即可），这样一来整个项目结构就比较明显了，客户端和服务端分离。\n\n![](http://upload-images.jianshu.io/upload_images/1495096-9537205523283645.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nstep2 修改routes文件夹\nroutes里默认有index.js和users.js两个路由文件，其中index.js是负责模板渲染的\n```\nvar express = require('express');\nvar router = express.Router();\n\n/* GET home page. */\nrouter.get('/', function(req, res, next) {\n  res.render('index', { title: 'Express' });\n});\n\nmodule.exports = router;\n```\n而users.js是直接返回一个字符串\n```\nvar express = require('express');\nvar router = express.Router();\n\n/* GET users listing. */\nrouter.get('/', function(req, res, next) {\n  res.send('respond with a resource');\n});\n\nmodule.exports = router;\n\n```\n既然我们删掉了views，那么index.js的代码肯定要修改的。我删掉了这两个文件，并新建了get.js和post.js文件用来接收和处理前端的ajax请求\n```\n//get.js\nmodule.exports=function(req,res){\n  console.log(req.query.userName);\n  res.json({code:200,data:\"this is a get request\"});\n}\n```\n```\n//post.js\nmodule.exports=function(req,res){\n    console.log(req.body.userName);\n    console.log(req.body.password);\n    res.json({code:200,data:\"this is a post request\"});\n}\n```\n另外，我还新建了一个名为router.js的文件，用来分配路由（默认是在app.js文件中进行路由分配的，但是一旦请求过多，app.js会十分冗长）\n```\nvar express=require('express');\nvar router=express.Router();\n\nvar get=require('./get');\nvar post=require('./post');\n\nrouter.get('/get.json',get);\nrouter.post('/post.json',post);\nmodule.exports=router;\n```\nstep3 修改app.js\n对模块加载做如下修改\n```\n//修改前\nvar index = require('./routes/index');\nvar users = require('./routes/users');\n//修改后\nvar router=require('./routes/router.js');\n```\n删掉视图引擎的设置\n```\n//删除下面的代码\napp.set('views', path.join(__dirname, 'views'));\napp.set('view engine', 'jade');\n```\n对静态资源的加载做一些更改，默认是在\"public\"文件夹下读取并加载静态资源的，现在我们设置为先从根路径读取文件，如果不存在则从\"client\"中读取文件\n```\n//修改前\napp.use(express.static(path.join(__dirname, 'public')));\n//修改后\nvar rootDir=path.resolve(__dirname);\nvar projectDir=path.resolve(__dirname,'../','client');\napp.use(express.static(rootDir));\napp.use(express.static(projectDir));\n```\n替换默认的路由加载，改为上面require的router。/api是一个虚拟路径，这样每当我们访问/api/xxx.json就会通过路由来分配不同的控制器完成业务逻辑\n```\n//修改前\napp.use('/', index);\napp.use('/users', users);\n//修改后\napp.use('/api',router);\n```\n我们还需要让根路径加载首页面\n```\napp.get('/', function(req, res){\n  res.sendFile(projectDir+'/index.html');\n});\n```\n由于不需要渲染视图，因此错误页面的处理也要进行修改，我这里仅仅是把错误信息返回给前端\n```\n//修改前\napp.use(function(err, req, res, next) {\n  res.locals.message = err.message;\n  res.locals.error = req.app.get('env') === 'development' ? err : {};\n  res.status(err.status || 500);\n  res.render('error');\n});\n//修改后\napp.use(function(err, req, res, next) {\n  res.locals.message = err.message;\n  res.locals.error = req.app.get('env') === 'development' ? err : {};\n  res.status(err.status || 500);\n  res.json({code:500,msg:\"error\"});\n});\n```\n\n#### 测试\n我们需要编写前端代码进行测试，这里我使用angular简单地发送get和post请求\n```\nangular.module(\"indexApp\",[])\n.controller(\"IndexCtrl\",function($scope,$http){\n    $scope.get=function(){\n        $http({\n            method:\"get\",\n            url:\"/api/get.json\",\n            params:{userName:\"sunnychuan\"}\n        }).then(function(res){\n            if(res.data.code==200){\n                console.log(res.data.data);\n            }\n            else if(res.data.code==500){\n                console.log(res.data.msg);\n            }\n        })\n    }\n    $scope.post=function(){\n        $http({\n            method:\"post\",\n            url:\"/api/post.json\",\n            data:{userName:\"sunnychuan\",password:\"qc\"}\n        }).then(function(res){\n            if(res.data.code==200){\n                console.log(res.data.data);\n            }\n            else if(res.data.code==500){\n                console.log(res.data.msg);\n            }\n        })\n    }\n})\n```\n同样的，使用npm start启动项目，在url中输入localhost:3000\n\n![](http://upload-images.jianshu.io/upload_images/1495096-95f59140377630af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n点击get按钮\n\n![](http://upload-images.jianshu.io/upload_images/1495096-c76452e4513b8840.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n![](http://upload-images.jianshu.io/upload_images/1495096-e4c897f0f0c7c1e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n点击post按钮\n\n![](http://upload-images.jianshu.io/upload_images/1495096-f69ba35095f8f03d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![](http://upload-images.jianshu.io/upload_images/1495096-e627f3d9e6e7e25d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n至此，基本的环境搭建成功，搭配mongodb会在之后的文章中介绍。","tags":["node"],"categories":["技术博客"]},{"title":"用ES6书写React","url":"/2016/11/03/2016-11-03-technology-react-es6/","content":"前段时间学习react+redux的时候发现现在大家基本上都是在用es6的方式编写react代码。由于习惯了react本身的编写方式，起初看得云里雾里。当自己实践过后发现es6+react确实能够让代码更加简洁，提高开发效率。\n### 起步\n首先需要安装react\n```\nnpm install react react-dom --save-dev\n```\n\n使用es6（7）需要babel转换器，本人使用的是webpack自动化工具\n```\nnpm install webpack --save-dev\nnpm install babel-preset-es2015 --save-dev //转换至es5\nnpm install babel-preset-react --save-dev //转换jsx至es5\nnpm install babel-preset-stage-2 --save-dev //支持es7\nnpm install babel-loader --save-dev //webpack的babel加载器\n```\n\n配置webpack\n```\n//webpack.config.js\nmodule.exports={\n\tentry:\"./main.js\",\n\toutput:{\n\t\tpath:__dirname,\n\t\tfilename:\"app.js\"\n\t},\n\tmodule:{\n\t\tloaders:[{\n\t\t\ttest:/\\.js$/,\n\t\t\texclude:/node_modules/,\n\t\t\tloader:\"babel-loader\",\n\t\t\tquery:{\n\t\t\t\tpresets:[\"es2015\",\"stage-2\",\"react\"]\n\t\t\t}\n\t\t}]\n\t}\n}\n```\n\n现在准备工作做好了，接下来的任务就是用新的方式编写入口文件。（main.js）\n### ES6-React\n#### 加载模块\n通过引入react.js和react-dom.js我们可以直接使用React和ReactDOM这两个对象，这是传统的方式\n```\n//html中需要先引入react.js和react-dom.js\nconsole.log(React);\nconsole.log(ReactDOM);\n```\n现在我们使用es6的方式\n```\n//不需要提前引入任何文件\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nconsole.log(React);\nconsole.log(ReactDOM);\n```\n#### 创建组件\n使用类来创建组件代替React.createClass\n```\nimport React from \"react\";\nclass MyComponent extends React.Component{\n//组件内部代码\n}\n```\n你也可以用另一种方式\n```\nimport React,{Component} from \"react\";\nclass MyComponent extends Component{\n//组件内部代码\n}\n```\n\n#### State/Props/PropTypes\n```\n//传统的react\nvar MyComponent=React.createClass({\n  getDefaultProps:function(){\n    return {\n      name:\"SunnyChuan\",\n      age:22\n    };\n  },\n  propTypes:{\n    name:React.PropTypes.string.isRequired,\n    age:React.PropTypes.number.isRequired\n  }\n});\n```\nes6允许将props和propTypes当作静态属性在类外初始化\n```\nclass MyComponent extends React.Component{}\nMyComponent.defaultProps={\n  name:\"SunnyChuan\",\n  age:22\n};\nMyComponent.propTypes={\n  name:React.PropTypes.string.isRequired,\n  age:React.PropTypes.number.isRequired\n};\n```\nes7支持直接在类中使用变量表达式，这也是我推荐的写法\n```\nclass MyComponent extends React.Component{\n  static defaultProps={\n    name:\"SunnyChuan\",\n    age:22\n  }\n  static propTypes={\n    name:React.PropTypes.string.isRequired,\n    age:React.PropTypes.number.isRequired\n  }\n}\n```\nstate和前两个不同，它不是静态的\n```\nclass MyComponent extends React.Component{\n  static defaultProps={\n    name:\"SunnyChuan\",\n    age:22\n  }\n  state={\n     isMarried:false\n  }\n  static propTypes={\n    name:React.PropTypes.string.isRequired,\n    age:React.PropTypes.number.isRequired\n  }\n}\n```\n#### 函数\nReact.createClass本身接收的是一个对象，对于对象中的方法，es6允许使用`key(){}`的形式取代`key:function(){}`\n```\nclass MyComponent extends React.Component{\n  state={\n    count:0\n  }\n  handleChange(){\n    this.setState({count:this.state.count+1});\n  }\n}\n```\n需要注意的是，由于使用class创建组件，react不会再自动帮我们绑定作用域了，我们需要自己手动解决\n```\nclass MyComponent extends React.Component{\n  state={\n    count:0\n  }\n  handleChange(){\n    this.setState({count:this.state.count+1});\n  }\n  render(){\n    return (\n      <div>\n        <h2>当前计数是：{this.state.count}</h2>\n        <button onClick={this.handleChange.bind(this)}>点击</button>\n      </div>\n    )\n  }\n}\n```\n如果你觉得这种每次都需要绑定的方法太麻烦，也可以在构造函数中去绑定\n```\nclass MyComponent extends React.Component{\n  constructor(props){\n    super(props);\n    this.handleChange=this.handleChange.bind(this);\n  }\n  state={\n    count:0\n  }\n  handleChange(){\n    this.setState({count:this.state.count+1});\n  }\n  render(){\n    return (\n      <div>\n        <h2>当前计数是：{this.state.count}</h2>\n        <button onClick={this.handleChange}>点击</button>\n      </div>\n    )\n  }\n}\n```\n如果你觉得这种方式也麻烦，可以使用es6的箭头函数（自动绑定作用域），但是前提是你的环境要支持es7，因为箭头函数相当于表达式声明函数的简写，只有es7支持在类中这么使用（类中使用表达式state/props/propTypes也只有es7支持）\n```\nclass MyComponent extends React.Component{\n  state={\n    count:0\n  }\n  handleChange=()=>{\n    this.setState({count:this.state.count+1});\n  }\n  render(){\n    return (\n      <div>\n        <h2>当前计数是：{this.state.count}</h2>\n        <button onClick={this.handleChange}>点击</button>\n      </div>\n    )\n  }\n}\n```\n\n#### 组件生命周期\n所有的组件生命周期都可以当作普通函数使用上述三种方式编写，componentWillMount比较特殊，它还可以在构造函数中编写\n```\nclass MyComponent extends React.Component{\n  componentWillMount(){\n    console.log(\"Hello SunnyChuan\");\n  }\n}\n//二者等价\nclass MyComponent extends React.Component{\n  constructor(props){\n    console.log(\"Hello SunnyChuan\")\n  }\n}\n```\n\n#### 扩展操作符\n使用react开发最常见的问题就是父组件要传给子组件的属性较多时比较麻烦\n```\nclass MyComponent extends React.Component{\n//假设MyComponent已经有了name和age属性\n  render(){\n    return (\n      <SubComponent name={this.props.name} age={this.props.age}/>\n     )\n  }\n}\n```\n使用扩展操作符可以变得很简单\n```\nclass MyComponent extends React.Component{\n//假设MyComponent已经有了name和age属性\n  render(){\n    return (\n      <SubComponent {...this.props}/>\n     )\n  }\n}\n```\n上述方式是将父组件的所有属性都传递下去，如果这其中有些属性我不需要传递呢？也很简单\n```\nclass MyComponent extends React.Component{\n//假设MyComponent有很多属性，而name属性不需要传递给子组件\n  var {name,...MyProps}=this.props;\n  render(){\n    return (\n      <SubComponent {...Myprops}/>\n     )\n  }\n}\n```\n上述方法最常用的场景就是父组件的class属性需要被单独提取出来作为某个元素的class，而其他属性需要传递给子组件。\n\n#### 模块化开发组件\n说了这么多，个人认为es6+react最吸引人的地方就是模块化开发，将每个小（大）组件当作一个模块\n```\n//father.js\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport {SonComponent} from \"son.js\";\nclass FatherComponent extends React.Component{ \n  //省去中间的业务逻辑\n  render(){\n    return (<SonComponent/>);\n  }\n}\nReactDOM.render(<FatherComponent/>,document.getElementById(\"ss\"));\n```\n```\n//son.js\nimport React from \"react\";\nclass SonComponent extends React.Component{\n  //省去中间的业务逻辑\n  render(){\n    return (<h2>\"SunnyChuan\"</h2>);\n  }\n}\nexport {SonComponent};\n```\n如果你把子组件的导出设置为default export，那么在导入时就不必再加{}\n```\n//father.js\nimport SonComponent from \"son.js\";\n```\n```\n//son.js\nexport default class SonComponent extends React.Component{\n  //省去中间的业务逻辑\n}\n```\n\n花一点时间学习es6（7）+react的开发方式，你会更加喜欢使用react。","tags":["react"],"categories":["技术博客"]},{"title":"ES6学习笔记（一）","url":"/2016/10/30/2016-10-30-technology-es6-1/","content":"### 最近学习了ES6，被它更简洁的代码编写方式、面向对象以及模块化开发所吸引。ES6有一定的学习成本而且知识点比较琐碎，我把自己经常用到的知识点进行了整理。\n\n#### 安装与配置\nes6很强大，遗憾的是所有浏览器都没有完美支持它。因此我们需要通过babel将es6转换成es5让我们的代码在浏览器端运行。\n\n我本人用的是webpack+babel，你也可以使用gulp或者直接将babel的browser.js引入，将type设为\"text/babel\"。\n\n首先安装webpack\n```\nnpm install webpack --save-dev \n```\n\nwebpack需要安装相应的loader加载器—babel-loader，别忘了安装转换规则—babel-preset-es2015\n```\nnpm install babel-loader --save-dev\nnpm install babel-preset-es2015 --save-dev\n```\n\n接下来简单地配置一下webpack.config.js文件\n```\nmodule.exports = {\n  entry: \"./main.js\",\n  output: {\n    path: __dirname,\n    filename: \"after.js\"\n  },\n  module: {\n    loaders: [\n      {\n        test: /\\.js$/,\n        loader: 'babel-loader',\n        query: {\n          presets: ['es2015']\n        }\n      }\n    ]\n  },\n}\n```\n\n上面的main.js就是我们即将要写的es6代码，通过在命令行输入`webpack`将其转化成es5并保存在after.js中，因此我们只需要引入after.js即可。如果你希望webpack可以实时监听并编译，可以安装webpack-dev-server，这里不多说明。\n\n小贴士：如果你在使用es6中的Generator、async的时候遇到了错误信息`regeneratorRuntime is not defined`，请单独安装babel-polyfill：在webpack.config.js的头部`var babelpolyfill = require(\"babel-polyfill\");`，将入口文件改写成`entry:[\"babel-polyfill\",\"./main.js\"],`，然后在你的js中`import \"babel-polyfill\"`。\n\n准备工作已经完成，接下来我们可以测试一下，我准备了一个用es6编写的main.js文件\n```\nclass MyClass{\n\tconstructor(x,y){\n\t\tthis.x=x;\n\t\tthis.y=y;\n\t}\n\tprint(){\n\t\treturn `(${this.x},${this.y})`;\n\t}\n}\nvar myclass=new MyClass(2,3);\nconsole.log(myclass.print());\n```\n\n运行webpack后看看生成的after.js里面都有啥\n```\n//部分代码\nvar MyClass = function () {\n\t\tfunction MyClass(x, y) {\n\t\t\t_classCallCheck(this, MyClass);\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\t_createClass(MyClass, [{\n\t\t\tkey: \"print\",\n\t\t\tvalue: function print() {\n\t\t\t\treturn \"(\" + this.x + \",\" + this.y + \")\";\n\t\t\t}\n\t\t}]);\n\t\treturn MyClass;\n\t}();\n    var myclass = new MyClass(2, 3);\n\tconsole.log(myclass.print());\n```\n可以看到webpack已经将es6转化为es5，现在可以尽情使用es6了。\n### let和const\n#### let\nlet是新的变量声明方式，使用方法类似于var，但是let声明的变量只在它所在的代码块内有效\n```\n{\n\tvar name=\"SunnyChuan\";\n\tlet age=22;\n}\nconsole.log(name); //\"SunnyChuan\"\nconsole.log(age);  //age is not defined\n```\n\nlet变量只在自己的块级作用域内有效，也就意味着使用let可以代替闭包解决常见的for循环引用同一个变量的问题\n```\nfor(let i=0;i<5;i++)console.log(i);  //0 1 2 3 4\n```\n\nlet不存在变量声明提升，必须先声明后使用\n```\nconsole.log(name); //ReferenceError\nlet name=\"SunnyChuan\";\n```\n\nlet不允许在同一个作用域内重复声明同一个变量（无论新变量是let/const/var）\n```\nlet name=\"SunnyChuan\";\nvar name=\"DannyQin\"; //报错\n```\n\n#### const\nconst是es6增加的另一个变量声明方式，它用来声明常量，并且声明后变量的值不能再更改。因此一旦声明必须初始化，不能稍后再赋值\n```\nconst a=100;\na=10; //TypeError\nconst b  //SyntaxError;\nb=100;\n```\n\nconst和let一样存在自己的作用域，个人认为除了变量的值是否可以改变以及是否必须声明立即初始化之外，let和const没有其他区别。需要注意的是，对于对象，数组等复合型的变量，const保证的是地址不变而不是值不变\n```\nconst arr=[1,2,3];\narr.push(4); //地址不变，改变值是可以的\narr=[5]; //修改了地址，报错\n```\n\n### 变量的解构赋值\nes6支持解构赋值的形式将变量的赋值简单化，数组/对象/字符串/数值/布尔/函数均可解构赋值。最为常用的是数组和对象。\n#### 数组的解构赋值\n只要等号两边的模式相同即可解构成功\n```\nvar [a,b,c]=[1,2,3] //a=1,b=2,c=3\nvar [a,,b] //a=1,b=3\nvar [a,..b] //a=1,b=[2,3]\n```\n\n当左边的数量大于右边时，右边会默认用undefined进行补充，导致解构不成功\n```\nlet [a,b,c]=[1,2] //a=1,b=2,c=undefined\n```\n\n允许指定默认值，默认值只有当左边的变量所对应的右边的值严格等于undefined才生效\n```\nvar [a,b,c=3]=[1,2]; //a=1,b=2,c=3\nvar [a,b,c=3]=[1,2,null]; //a=1,b=2,c=null\n```\n\n#### 对象的解构赋值\n与数组不同的是，对象解构赋值依靠的是key值，因此只要左边和右边key值同名即可（变量名等于属性名），无所谓顺序，而数组是按照顺序赋值的\n```\nvar {name,age}={name:\"SunnyChuan\",age:22}; //name=\"SunnyChuan\" age=22 \n//相当于\nvar {name:name,age:age}={name:\"SunnyChuan\",age:22};\n```\n\n按照上面的匹配方式，变量名必须等于属性名，如果不相等则匹配失败。如果变量名不等于属性名，只能使用属性名：变量名的形式，不能省去变量名。这时候，属性只不过是一个模式，真正被赋值的是变量\n```\nvar {name:myName,age:myAge}={name:\"SunnyChuan\",age:22};\n//name is not defined, age is not defined, myName=\"SunnyChuan\", myAge=22\n```\n\n对象解构赋值也提供了默认值，与数组相同，只有属性值严格等于undefined时才生效\n```\nvar {name,age=22}={name:\"SunnyChuan\"} //name=\"SunnyChuan\" age=22\nvar {name,age=22}={name:\"SunnyChuan\",age:null} //name=\"SunnyChuan\" age=null\n```\n\n解构赋值最常用的地方就是交换变量。不需要额外的临时变量temp，一句代码就搞定\n```\n[x,y]=[y,x]\n```\n\n### 字符串/数值/数组的扩展\n#### 字符串的扩展\nincludes(str)，返回布尔值，是否在当前字符串中找到了str\n```\n\"SunnyChuan\".includes(\"Chuan\"); //true\n```\n\nstartsWith(str)，返回布尔值，当前字符串是否以str开头\n```\n\"SunnyChuan\".startsWidth(\"Sunny\"); //true\n```\n\nendsWith(str)，返回布尔值，当前字符串是否以str结尾\n```\n\"SunnyChuan\".endsWith(\"Chuan\"); //true\n```\n\nrepeat(n)，将当前字符串重复n次（可以理解为在原有的基础上重复n-1次）并返回新字符串，如果n是小数则向下取整。当n小于等于0时，返回空字符串\n```\n\"x\".repeat(3); // \"xxx\"\n```\n\n模板字符串\n```\nvar name=\"SunnyChuan\";\nvar str=`hello ${name},this is ES6 `;\n//等同于\"hello\"+name+\",this is ES6\";\n```\n\n#### 数值的扩展\nNumber.isFinite(n)，布尔值，检查n是否有穷，与es5的isFinite()不同的是，它不会进行类型转换，因此只对真正的数值有效\n```\nNumber.isFinite(10); //true\nNumber.isFinite(NaN); //false\nNumber.isFinite(Infinity); //false\nNumber.isFinite(\"10\"); //false\n```\n\nNumber.isNaN(n)，布尔值，检查n是否是NaN，与es5的isNaN()不同的是，它不会进行类型转换，因此只对真正的NaN有效\n```\nNumber.isNaN(NaN); //true\nNumber.isNaN(\"str\"); //false\n```\n\nNumber.isInteger(n)，布尔值，检查n是否是整数，需要注意1.0和1是同一个值\n```\nNumber.isInteger(1); //true\nNumber.isInteger(1.0); //true\nNumber.isInteger(1.2); //false\n```\n\n Math.trunc(n)，去除小数部分并返回（正数向下取整，负数向上取整）\n ```\n Math.trunc(1.2); //1\n Math.trunc(-1.2); //-2\n ```\n\nMath.sign(n)，布尔值，n是正数返回+1，是负数返回-1，0返回0，-0返回-0，其他值返回NaN\n```\nMath.sign(100); //+1\nMath.sign(-100); //-1\nMath.sign(0); //0\nMath.sign(-0); //-0\nMath.sign(\"str\"); //NaN\n```\n\n#### 数组的扩展\nArray.from(list)，将list转化成真正的数组，常用于将nodeList/arguments等伪数组\n转化成数组\n```\nvar obj={a:1,b:2,c:3};\nArray.from(obj); //[1,2,3]\nvar div=document.getElementsByTagName(\"div\");\nArray.from(div); //[[object HTMLDivElement],[object HTMLDivElement],[object HTMLDivElement]]\n```\n\nincludes(n)，布尔值，检查当前数组是否包含n，可以接收两个参数，第二个参数代表搜索的起始位置（负数代表从后往前）\n```\n[1,2,3,4].include(2); //true\n[1,2,3,4].include(2,2); //false\n[1,2,3,4].include(2,-3); //true\n```\n\n数组新增三种遍历方式：entries()（遍历key和value）/keys()（遍历key）/values()（遍历value）\n```\nfor(let v of [\"a\",\"b\",\"c\",\"d\"].values()){\n\tconsole.log(v);\n} //\"a\" \"b\" \"c\" \"d\"\n\nfor(let k of [\"a\",\"b\",\"c\",\"d\"].keys()){\n\tconsole.log(k);\n} //0 1 2 3\n\nfor(let [k,v] of [\"a\",\"b\",\"c\",\"d\"].entries()){\n\tconsole.log(k,v);\n} //0 \"a\" 1 \"b\" 2 \"c\" 3 \"d\"\n```\n### 函数和对象的扩展\n#### 函数的扩展\nes6支持函数的参数设置默认值，但是这些参数必须位于函数的尾部，并且参数的变量是默认声明的，因此不能用let/const再次声明\n```\nfunction func(x,y=5){\n\tconsole.log(y); //5\n\tlet y=3; //error\n}\n```\n\n扩展运算符，用于将数组（伪数组）展开成参数序列\n```\nconsole.log(...[1,2,3]); //1 2 3\n[...document.getElementsByTagName(\"div\")]; //[[object HTMLDivElement],[object HTMLDivElement],[object HTMLDivElement]]\n```\n\n扩展运算符有很多应用场景，这里列举三个\n1. 数组合并\n```\n[1,2,3].concat([4,5,6]); //es5\n[1,2,3,...[4,5,6]]; //es6\n```\n\n2.与解构结合（用于生成数组）\n```\nlet [a,b,...c]=[1,2,3,4,5]; //a=1,b=2,c=[3,4,5] 扩展运算符必须放在最后\n```\n\n3.Math.max的参数不支持数组，在es5中需要用到apply。用扩展运算符可以解决该问题\n```\nMath.max.apply(Math,[1,2,3]); //es5\nMath.max(...[1,2,3]); //es6 相当于Math.max(1,2,3)\n```\n\n箭头函数，如果不需要参数则用圆括号代替参数部分，如果函数体有多行代码则用大括号括起来\n```\nvar func=x=>x*2; //var func=function(x){return x*2;}\nvar func=()=>true; //var func=function(){return true;}\nvar func=(x,y)=>{var z=x+y;console.log(z);} //var func=function(x,y){var z=x+y;console.log(z);}\nvar func=()=>({a:1,b:2}); //返回对象需要用圆括号包起来，圆括号代表函数体，花括号代表这是一个对象\n```\n\n函数绑定，使用a::b的形式取代传统的bind/call/apply\n```\na::b; //b.bind(a);\na::b(...arguments); //b.apply(a,arguments);\n```\n#### 对象的扩展\nes6允许在对象中只写key，这样默认了value等于key所代表的变量值\n```\nvar [name,age]=[\"SunnyChuan\",22];\nvar obj={name,age}; //obj={name:\"SunnyChuan\",age:22} \n//相当于obj={name:name,age:age};\n```\n\n对象的方法也可以简写\n```\nvar obj={\n\tfunc(){\n\t\t//函数体\n\t}\n}\n//相当于\nvar obj={\n\tfunc:function(){\n\t\t//函数体\n\t}\n}\n```\n\nObject.assign(obj,obj1,obj2,...)，将obj1/obj2/...与obj进行拼接（修改obj本身）\n```\nvar [obj,obj1,obj2]=[{a:1},{b:2},{c:3}];\nObject.assign(obj,obj1,obj2);\nconsole.log(obj); //{a:1,b:2,c:3}\n```\n\nObject.is(obj1,obj2)，布尔值，判断两个值是否严格相等，与===不同的是，+0不等于-0，NaN等于NaN\n```\nObject.is(100,100); //true\nObject.is(NaN,NaN); //true\nObject.is(+0,-0); //false\nObject.is({a:1},{a:1}); //false\n```","tags":["javascript"],"categories":["技术博客"]},{"title":"ES6学习笔记（二）","url":"/2016/10/30/2016-10-30-technology-es6-2/","content":"### Set和Map\n#### Set\nSet类似于数组，但是里面成员的值不能重复。Set构造函数可以传入一个数组用于初始化\n```\nvar s=new Set();\n[1,2,3].map(i=>s.add(i));\nfor(var i of s){console.log(s)}; //1 2 3\n\nvar s=new Set([1,2,3]);\nfor(var i of s){console.log(s)}; //1 2 3\n```\n\nSet拥有以下属性和方法\n1.size，返回成员个数\n2.add(value)，添加值，返回自身\n3.delete(value)，删除值，返回布尔值，代表是否删除成功\n4.has(value)，布尔值，表示是否含有value成员\n5.clear()，无返回值，删除所有成员\n\n遍历操作\n1.keys()\n2.values()\n3.entries()\n4.forEach()\n由于Set中只有值，因此keys()等于values()\n```\nvar s=new Set([1,2,3,4]);\nfor(var i of s)console.log(i); //1 2 3 4\nfor(var i of s.keys())console.log(i); //1 2 3 4\nfor(var i of s.values())console.log(i); //1 2 3 4\nfor(var [k,v] of s.entries())console.log(`${k} ${v}`); //1 1 2 2 3 3 4 4，key值等于value值 \ns.forEach((v,k)=>{console.log(`${v} ${k}`)}); //1 1 2 2 3 3 4 4\n```\n\n通过Set可以很方便地实现数组去重而不必借用一次循环\n```\nvar deleteSample=arr=>{var s=new Set(arr);return [...s];}\nconsole.log(deleteSample([1,1,2,2,3,3,4])); //[1,2,3,4]\n```\n\n#### Map\n对象只能使用字符串当作key，而Map可以使用任意类型作为key。Map构造函数可以传入一个数组用于初始化，该数组由若干个数组构成，每个数组包含key和value\n```\nvar m=new Map(),obj={a:1};\nm.set(obj,\"key is Object\"); //将obj作为key，value是一个字符串\nvar m=new Map([[\"a\",1],[\"b\",2],[\"c\",3]]);\nfor(var [k,v] of m)console.log(`${k} ${v}`); //a 1 b 2 c 3\n```\n\nMap拥有以下属性和方法\n1.size，返回成员个数\n2.set(key,vaule)，设置key所对应的value，如果key存在则覆盖旧的value，如果不存在则新建key并赋值value。返回Map本身\n3.get(key)，获取key所对应的value\n4.has(key)，布尔值，判断Map中是否存在key键\n5.delete(key)，删除key键，返回布尔值，表示是否删除成功\n6.cleear()，没有返回值，删除所有成员\n\n遍历操作\n1.keys()\n2.values()\n3.entries()\n4.forEach()\n```\nvar m=new Map([[\"a\",1],[\"b\",2],[\"c\",3]]);\nfor(var [k,v] of m)console.log(`${k} ${v}`); // a 1 b 2 c 3\nfor(var k of m.keys())console.log(k); //a b c\nfor(var v of m.values())console.log(v); //1 2 3\nfor(var [k,v] of m.entries())console.log(`${k} ${v}`); //a 1 b 2 c 3\nm.forEach((v,k)=>{console.log(`${v} ${k}`)}); //1 a 2 b 3 c\n```\n\n通过扩展运算符可以将Map转换成数组\n```\nvar m=new Map([[\"a\",1],[\"b\",2],[\"c\",3]]);\nconsole.log([...m.keys()]); //a b c\nconsole.log([...m.values()]); //1 2 3\nconsole.log([...m.entries()]); //[[\"a\",1],[\"b\",2],[\"c\",3]]\nconsole.log([...m]); //[[\"a\",1],[\"b\",2],[\"c\",3]]\n```\n\n### Iterator和for...of循环\n#### Iterator\nIterator为各种数据结构提供统一的遍历机制。在es6中，数组/伪数组/Set/Map具备原生的Iterator接口\n```\nlet arr=[1,2,3];\nvar it=arr[Symbol.iterator]();\nit.next(); //{value:1,done:false}\nit.next(); //{value:2,done:false}\nit.next(); //{value:3,done:false}\nit.next(); //{value:undefined,done:true}\n```\n#### for...of循环\nfor...of循环内部调用的是Symbol.iterator方法，也就是说，只要是支持Symbol.iterator方法的数据结构就可以用for...of循环，与for...in不同的是，for...of可以返回键值和键名（默认数组只返回键值，可以通过keys()/values()/entries()进行修改），而for...in只能返回键名\n```\nvar arr=[1,2,3];\nfor(var i in arr)console.log(i); //0 1 2\nfor(var i in arr)console.log(arr[i]); //1 2 3\nfor(var i of arr)console.log(i); //1 2 3\n```\n\n普通的对象不支持for...of循环，可以使用Object.keys方法将对象的键名生成一个数组，遍历这个数组。其实相当于for...in\n```\nvar obj={a:1,b:2,c:3};\nfor(var k of Object.keys(obj))console.log(`${k} ${obj[k]}`); //a 1 b 2 c 3\nfor(var k in obj)console.log(`${k} ${v}`); //a 1 b 2 c 3\n```\n\n### Class\n#### 创建Class和实例\nes6支持类似于Java、C++等高级程序设计语言的类的写法，但是它的底层仍然使用的是es5的面向对象声明方式，相当于是语法糖，es6将定义在this上的属性使用es5的构造函数的方式，对方法使用原型的方式，和es5的混合模式是一样的\n```\nclass MyClass{\n\tconstructor(x,y){\n\t\tthis.x=x;\n\t\tthis.y=y;\n\t}\n\tprint(){\n\t\tconsole.log(`(${this.x},${this.y})`);\n\t}\n}\nvar myclass=new MyClass(2,3);\nmyclass.print(); //(2,3)\nmyclass.hasOwnProperty(\"x\"); //true\nmyclass.hasOwnProperty(\"print\"); //false\n```\n\n可以通过Object.assign为类添加方法\n```\nObject.assign(MyClass.prototype,{printName(){/**/},printAge(){/**/}});\n```\n\nClass也可以使用表达式的形式定义，无论是表达式形式还是一般形式，Class均不存在变量声明提升，必须先声明后使用\n```\nvar MyClass=class{/**/};\nvar other=new OtherClass(); //ReferenceError\nvar OtherClass=class{/**/};\n```\n\n#### Class的继承\nes6的Class继承和Java相似，使用extends关键字。必须在constructor中调用super方法，并且只有调用了super后才能使用this，也就是说super必须放在所有this的前面\n```\nclass SubClass extends MyClass{\n\tconstructor(x,y,z){\n\t\tsuper(x,y); //调用父类的构造函数\n\t\tthis.z=z;\n\t}\n\tprint(x,y,z){\n\t\tconsole.log(`(${this.x},${this.y},${this.z})`); //重写父类的print\n\t}\n}\nvar sub=new SubClass(2,3,4;\nconsole.log(sub instanceof SubClass); //true\nconsole.log(sub instanceof MyClass); //true\n```\n\n可以通过object.getPrototypeOf方法从子类上获取父类，用于判断一个类是否继承自另一个类\n```\nconsole.log(Object.getPrototypeOf(SubClass)===MyClass); //true\n```\n\nes6允许继承原生构造函数（Boolean/Number/String/Array/Date/Function/RegExp）\n```\nclass MyNumber extends Number{\n\tconstructor(...agrgs){\n\t\tsuper(...args);\n\t}\n\t//添加一些方法\n}\n```\n\n#### Class的取值和存值函数\nes6支持类似于C#的get和get方法，但是调用它们的时候是以属性的形式调用，而不是方法\n```\nclass MyClass{\n\tconstructor(x){\n\t\tthis.x=x;\n\t}\n\tget getX(){\n\t\treturn this.x;\n\t}\n\tset setX(xx){\n\t\tthis.x=xx;\n\t}\n}\nvar myclass=new MyClass(2);\nconsole.log(myclass.getX); //2\nmyclass.setX=3;\nconsole.log(myclass.getX); //3\n```\n\n#### Class的静态方法\n在一个方法上加上static关键字表示该方法是一个静态方法，它不能被实例所调用，只能直接通过类去调用\n```\nclass MyClass{\n\tstatic print(){\n\t\tconsole.log(\"hello world\");\n\t}\n}\nvar myclass=new MyClass();\nmyclass.print(); //TypeError\nMyClass.print(); //\"hello world\"\n```\n\n静态方法可以被子类继承，在子类中仍然是静态方法，可以通过super调用父类的静态方法\n```\nclass SubClass extends MyClass{\n\tstatic print(){\n\t\tsuper.print();\n\t}\n}\nSubClass.print(); //\"hello world\"\n```\n\n### 模块的import和export\n#### export\nexport命令用于规定模块的对外接口，允许其他模块通过import加载该模块\n```\n//export.js\nexport var obj={a:1,b:2,c:3};\nexport var name=\"SunnyChuan\";\nexport var age=22;\n```\n\n如果觉得上面的形式较繁琐，可以简写为\n```\nvar [obj,name,age]=[{a:1,b:2,c:3},\"SunnyChuan\",22];\nexport {obj,name,age};\n```\n\n模块输出的变量就是它的名字，可以通过as进行重命名\n```\nvar [obj,name,age]=[{a:1,b:2,c:3},\"SunnyChuan\",22];\nexport {obj as o,name as n,age as a}; \n```\n\n#### import\nexport用于导出模块，import用于加载模块，注意要加载的模块的名字必须与导出的模块的名字相同。import具有声明提升，会提升到整个代码块的头部\n```\n//import.js\nimport {obj,name,age} from \"./export.js\";\n//如果export的时候已经重命名了，可以import {o,n,a} from \"./export.js\";\nconsole.log(obj); //{a:1,b:2,c:3}\nconsole.log(name); \"SunnyChuan\"\nconsole.log(age); 22\n```\n\n同export，在import的时候也可以为模块重命名\n```\nimport {obj as o,name as n,age as a} form \"./exoprt.js\"\n```\n\n使用“*”加载整个模块，然后用as指定给一个对象，通过调用对象的属性使用相应模块，也可以使用module命令取代import实现整体加载\n```\nimport * as qc from \"./exports.js\";\nconsole.log(qc.obj); //{a:1,b:2,c:3}\nconsole.log(qc.name); \"SunnyChuan\"\nconsole.log(qc.age); 22\n\nmodule qc from \"./exports.js\";\nconsole.log(qc.obj); //{a:1,b:2,c:3}\nconsole.log(qc.name); \"SunnyChuan\"\nconsole.log(qc.age); 22\n```\n\n以上是我经常用到的es6的知识点，想要学习更多强大的功能（Proxy/Reflect/Symbol/二进制数组/Generator/异步编程）或者想要更加细致地学习es6，可以访问阮一峰的教程[ECMAScript 6入门](http://es6.ruanyifeng.com/)，本人也是在这里学习的。","tags":["javascript"],"categories":["技术博客"]},{"title":"Blob对象","url":"/2016/08/02/2016-08-02-technology-blob/","content":"前几天写公司的SpreadJS控件的测试用例时遇到一个需求，不通过input标签的type=file的形式来实现本地文件选择，而是直接指定自己想要上传的文件（因为模拟ui行为的测试会占用大量的时间，影响测试效率）。一开始我认为这是不可能实现的，因为浏览器的安全性原因，js是不能直接访问系统文件的（node.js除外）。ie浏览器支持使用FileSystemObject接口来访问本地文件，但是其他浏览器均没有实现。初步方案是利用后端语言去访问系统文件然后转换成base64格式返回给前端，前端将base64转成file文件。\n#### 一、后端操作\n后端语言可以很轻松地去访问本地文件，我将文件对象存入到byte数组中并转换成了base64的字符串传给前端。后端代码就不写了，很简单。\n<br>\n#### 二、前端操作\n我想通过后端的base64字符串来生成File对象的实例。这里就需要了解input标签形式的文件上传的底层原理。\n#### 1.input生成文件对象的原理\n查阅w3c的文档得知：在 HTML 文档中` <input type=\"file\"> `标签每出现一次，一个 FileUpload 对象就会被创建。\n\n该元素包含一个文本输入字段，用来输入文件名，还有一个按钮，用来打开文件选择对话框以便图形化选择文件。当用户选择了一个或多个文件点击\"打开\"时，js会生成一个FileList数组来保存用户所选择的文件。FileList包含了一个或多个File对象。可以通过`document.getElemenById(\"uploadFile\").files`来进行访问。处于安全性的考虑，File对象不会暴露出文件的内容，它只提供了一些只读的属性来描述修改时间、文件类型、长度、名字等。\n\n![](http://upload-images.jianshu.io/upload_images/1495096-0895fa2984313aad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n<br>\n#### 2.创建File对象\njs有一个底层的Blob对象，它是一个包含有只读原始数据的类文件对象。File对象就继承自Blob对象并扩展了系统文件的支持。\n\nBlob对象的构造函数（来自MDN）\n```\nBlob Blob(\n  [optional] Array parts,\n  [optional] BlobPropertyBag properties\n);\n```\n第一个参数是一个数组，里面可以是DOMString，也可以是TypeArray或者Blob。\n这里需要解释一下TypedArray：在JS语言中，数值只有一种称为Number的类型，而不像C语言或底层CPU指令那样区分是整型还是浮点型，是有符号的还是无符号的，是32位的还是64位的。Typed Array的主要是为了弥补JS处理二进制格式数据的不足，利用Typed Array可以非常方便地操作二进制的数据。TypedArray包括Int32Array、Uint8Array、Float32Array等，也可以是连续的内存缓冲区ArrayBuffer或者工具类DataView。\n```\nvar myFile=new Blob([u8arr],{type : 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'});\n```\n第一个参数是一个Uint8Array的TypedArray类型，它是一个8比特的无符号的int数组，通过base64转换而来。第二参数是该文件的mime类型，不同的文件类型可以参考w3c的mime手册。\n<br>\n#### 3.base64的转换\n还剩最后一个问题，如何把base64转成Uint8Array?\njs提供了window.atob(base64)的方式对base64进行解码。再通过charCodeAt()的方式转成Uint类型。代码如下\n```\nvar bytes=window.atob(base64),      //解码  \n    n=bytes.length,\n    u8arr=new Uint8Array(n),\nwhile(n--){\n    u8arr[n]=bytes.charCodeAt(n);   //将编码转换成Unicode编码\n}\n```\n我对这一操作做了封装\n```\n//假设有一个xlsx文件\nfunction createFile(urlData){\n     var bytes=window.atob(urlData),\n         n=bytes.length,\n         u8arr=new Uint8Array(n);\n     while(n--){\n          u8arr[n]=bytes.charCodeAt(n);\n     }\n     return new Blob([u8arr],{type:'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'}});\n}\nvar str=\"\";   //str接收来自后端返回的base64\nvar myFile=createFile(str);\n```\n现在就大功告成了。前端的文件对象已经成功生成。\n<br>\n#### 4.最终测试\n我在代码中创建一个链接去下载这个文件\n```\nvar a = document.createElement(\"a\");\na.href =window.URL.createObjectURL(myFile); //下载路径指向这个文件对象 \na.download = \"SunnyChuan.xlsx\"; \na.click();    //指定页面自动下载文件\ndocument.body.appendChild(a);\n```\n页面打开后会自动下载文件\n\n![](http://upload-images.jianshu.io/upload_images/1495096-63f4eab0b989b958.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n我们把文件打开测试一下整个流程中有没有数据损失\n\n![](http://upload-images.jianshu.io/upload_images/1495096-d471e0364e320580.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n从图中可以看出文件完成无损地传到了前端。\n\n这里有一个小插曲:用ie浏览器是无法下载的，因此需要做hack:、\n```\nif(navigator.appVersion.toString().indexOf(\".NET\")>0){\n     window.navigator.msSaveBlob(myFile, \"SunnyChuan.xlsx\");\n}\nelse{\n        var a = document.createElement(\"a\");\n        a.href =window.URL.createObjectURL(myFile); \n        a.download = \"SunnyChuan.xlsx\"; \n        a.click(); \n        document.body.appendChild(a);\n}  \n```\n附上完整的代码\n```\nfunction createFile(urlData,fileType){\n     var bytes=window.atob(urlData),\n         n=bytes.length,\n         u8arr=new Uint8Array(n);\n     while(n--){\n          u8arr[n]=bytes.charCodeAt(n);\n     }\n     return new Blob([u8arr],{type:fileType});\n}\nvar str=\"\";   //str接收来自后端返回的base64\nvar fileType=\"\";//指定mime\nvar myFile=createFile(str,fileType);\nif(navigator.appVersion.toString().indexOf(\".NET\")>0){\n     window.navigator.msSaveBlob(myFile, \"SunnyChuan.xlsx\");\n}\nelse{\n        var a = document.createElement(\"a\");\n        a.href =window.URL.createObjectURL(myFile); \n        a.download = \"SunnyChuan.xlsx\"; \n        a.click(); \n        document.body.appendChild(a);\n}  \n```\n#### 三、总结\njs一般是不可以直接访问本地文件的，但是可以通过一些间接的方式去实现。js的文件操作一般用于下载文件以及保存图片。我实习的公司就是通过将产品内部的图片转成base64，在需要使用的时候再转换回图片，这种方式不需要产品附带图片文件，产品最终只有一个js文件，极大地减少了产品尺寸。","tags":["javascript"],"categories":["技术博客"]},{"title":"水平垂直居中那些事","url":"/2016/03/15/2016-03-15-technology-h-v-center/","content":"关于水平垂直居中想必大家一定不陌生了，对于前端工程师来说它是基础中的基础也是重点中的重点，我在刚刚接触div+css布局的时候经常因为如何实现水平垂直居中而困扰。下面是我不断积累和总结出来的常见实现方案。\n<br>\n### 一、水平居中\n#### 1.内联元素\n```\ntext-align:center;\n```\n#### 2.块级元素\n上下外边距为0，左右外边距自适应。\n```\nmargin:0 auto;\n```\n<br>\n### 二、水平垂直居中\n#### 1.宽高固定时\n通过绝对定位和外边距来实现。缺点十分明显，不能自适应。不支持百分比尺寸和min-/max-属性设置并且当含有内边距的时候需要一定的计算量。\n```\n#parent\n{\n\theight:200px;\n\twidth:200px;\n\tbackground: yellow;\n\tposition: relative;\n}\n#child\n{\n\theight: 100px;\n\twidth: 100px;\n\tbackground: red;\n\tposition: absolute;\n\tleft: 50%;\n\ttop:50%;\n\tmargin-left:-50px;/*如果有padding的话就是(width+内边距)/2*/\n\tmargin-top: -50px;/*同上*/\n}\n```\n<br>\n#### 2.改进版\n当宽高不固定的时候，可以通过css3的transform的translate属性来进行子层的位置调整。这种方案是上述方案的改进版，但是需要实现兼容各浏览器的hack代码。\n```\n#parent\n{\n\theight:200px;\n\twidth:200px;\n\tbackground: yellow;\n\tposition: relative;\n}\n#child\n{\n\theight: 100px;\n\twidth: 100px;\n\tbackground: red;\n\tposition: absolute;\n\tleft: 50%;\n\ttop:50%;\n\ttransform:translate(-50%,-50%);\n}\n```\n<br>\n#### 3.换一种思路\n既然块级元素可以通过margin:0 auto来实现水平居中，那可不可以使用margin:auto来实现水平垂直居中呢？当然可以，不过需要先做一些铺垫。\n```\n#parent1\n{\n\theight:200px;\n\twidth:200px;\n\tbackground: yellow;\n\tposition: relative;\n}\n#child1\n{\n\theight: 100px;\n\twidth: 100px;\n\tbackground: red;\n\tposition: absolute;\n\tleft: 0;\n\tright:0;\n\ttop:0;\n\tbottom:0;\n\tmargin:auto;\n}\n```\n这种方案也是我经常使用的，它支持跨浏览器，包括IE8-IE10.无需其他特殊标记，支持百分比%属性值和min-/max-属性，完美支持图片居中。\n<br>\n#### 4.不用绝对定位行不行？强大的table\n利用table本身的特性来实现水平垂直居中，总的说来这可能是最好的居中实现方法，因为内容块高度会随着实际内容的高度变化，浏览器对此的兼容性也好。唯一的美中不足就是需要在父层和子层之间增加一个中间层。\n```\n#parent\n{\n\theight:200px;\n\twidth:200px;\n\tbackground: yellow;\n\tdisplay: table;/*!!*/\n}\n#middle\n{\n\tdisplay: table-cell;/*!!*/\n\tvertical-align: middle;/*!!*/\n}\n#child\n{\n\theight: 100px;\n\twidth: 100px;\n\tbackground: red;  \n    margin: 0 auto;/*!!*/ \n}\n```\n<br>\n#### 5.说个简单的——文字水平垂直居中\n假如只有一个层，这个层的高度已知并且这个层中只有文字。那么可以让文字的行高等于层的高度来实现垂直居中，利用text-align属性实现水平居中。\n```\ndiv\n{\n    width:200px;\n    height:200px;\n    background:yellow;\n    line-height:200px;\n    text-align:center;\n}\n```\n<br>\n#### 6.未来的主流——Flexbox\n对于flexbox来说，解决水平垂直居中简直小菜一碟，它甚至可以用来解决更加复杂的布局问题。但是flexbox的兼容性不是很高，需要大量的hack代码，而且不支持IE8/IE9。\n```\n#parent\n{\n\twidth:200px;\n\theight:200px;\n\tbackground: yellow;\n\tdisplay: -webkit-box;  /* 老版本语法: Safari,  iOS, Android browser, older WebKit browsers.  */\n    display: -moz-box;    /* 老版本语法: Firefox (buggy) */ \n    display: -ms-flexbox;  /* 混合版本语法: IE 10 */\n    display: -webkit-flex;  /* 新版本语法： Chrome 21+ */\n    display: flex;       /* 新版本语法： Opera 12.1, Firefox 22+ */\n\n    /*垂直居中*/\t\n    /*老版本语法*/\n    -webkit-box-align: center; \n    -moz-box-align: center;\n    /*混合版本语法*/\n    -ms-flex-align: center; \n    /*新版本语法*/\n    -webkit-align-items: center;\n    align-items: center;\n            \n    /*水平居中*/\n    /*老版本语法*/\n    -webkit-box-pack: center; \n    -moz-box-pack: center; \n    /*混合版本语法*/\n    -ms-flex-pack: center; \n    /*新版本语法*/\n    -webkit-justify-content: center;\n    justify-content: center;\n}\n#child\n{\n\twidth:100px;\n\theight:100px;\n\tbackground: red;\n}\n```\n<br>\n#### 7.多个块级元素的居中\n将子层（块级）设置为inline-block，高度和父层一致。可以自适应。\n```\n#parent\n{\n\twidth:500px;\n\theight:100px;\n\tbackground: yellow;\n\ttext-align: center;\n}\n#child1,#child2,#child3\n{\n\twidth:100px;\n\theight:100px;\n\tbackground: red;\n\tdisplay:inline-block;\n}\n```","tags":["css"],"categories":["技术博客"]},{"title":"Sass初学","url":"/2016/03/10/2016-03-10-technology-sass/","content":"Sass作为css预处理器的一种，极大方便了我们编写css代码。与Less相比较，我个人更加喜欢使用Sass，因为它的代码风格更加接近高级程序设计语言。\nSass上手并不难，可以参考[官方文档](http://sass.bootcss.com/docs/sass-reference/)学习。\n### 安装Sass\n#### 1.安装ruby\nSass依赖于ruby，可以点击[这里](http://rubyinstaller.org/downloads)安装，在安装过程中勾选Add Ruby executables to your PATH。\n#### 2.安装Sass\n安装好ruby后，打开Start Command Prompt with Ruby，输入下面命令来进行安装。\n```\ngem install sass\n```\n\n可以通过\n```\nsass -v\n```\n来查看版本，这也正说明了Sass已经安装成功了。\n<br>\n### 编译Sass\n#### 1.命令行编译\n单文件一次性编译\n```\nsass style.scss style.css\n```\n单文件监听\n```\nsass --watch style.scss:style.css\n```\n#### 2.Koala\n在Less初学篇里已经介绍过，Koala同样可以编译Sass文件，但是这里需要注意，ruby环境默认是不支持中文编码的，因此需要将Koala文件夹中的\\rubygems\\gems\\sass-版本\\lib\\sass里面的engine.rb添加一行代码Encoding.default_external = Encoding.find('utf-8')(放在所有require xxx后面即可)。\n#### 3.使用sublime的插件或者webstorm\nsublime支持安装编译Sass文件的插件，webstorm本身就自带编译Sass，这里就不详细介绍了。\n#### 4.使用在线编译器 \n[戳这里](http://www.sassmeister.com/)\n<br>\n### Sass常用语法\nsass有两种后缀名文件：一种后缀名为sass，不使用大括号和分号；另一种就是scss(支持css3，推荐使用)\n#### 1.文件导入\n使用@import \"文件名\"来导入css或scss文件，如果导入的是scss文件，那么被导入的文件(一个或多个)都会被编译最终只生成一个css文件。导入的scss文件可以省去后缀。如果导入的是css文件，那么它将以被导入的形式出现在那么最终生成的css中。\n\n```\n@import \"style\"//省略后缀的style.scss\n```\n<br>\n#### 2.注释\n与Less相同，Sass有两种注释：编译到css文件的/**/和不被保存的//。\n<br>\n#### 3.变量\n使用\"$变量名\"的方式来声明一个变量，与Less的@变量名不同，Sass的这种声明方式更加接近高级程序设计语言。\n```\n$color:blue;\n.div{\n    background-color:$color;\n}\n```\n特殊变量：一般用于属性，形式为#{变量名}。\n```\n$var:left;\n.div{\n    border-#{$var}:1px solid black;//border-left\n}\n```\n<br>\n#### 4.嵌套\nSass支持选择器的嵌套，使得父子关系和代码结构更加清晰。\n```\n.father{\n    width:100px;\n    height:100px;\n    .son{\n        background-color:blue;\n        &:hover{\n             background-color:red;//&匹配它的上一级选择器\n        }\n    }\n}\n```\n属性嵌套\n```\n.div{\n    width:100px;\n    height:100px;\n    border:{    //注意有:\n        radius:10px;//相当于border-radius:10px\n    }\n}\n```\n@at-root\n@at-root可以让它后面的选择器跳出嵌套，自己作为根。\n```\n.father{\n    .son{\n        @at-root .skip{\n        }\n    }\n}\n//.father{}\n//.father .son{}\n//.skip{}\n```\n<br>\n#### 5.mixin 混合\nmixin可以实现类似于函数的功能，它可以无参，可以有参，也可以指定默认参数。用法和Less相似。\n通过@mixin来创建一个混合，通过@include来使用它。\n\n通过无参的mixin来创建一个代码块\n```\n@mixin init{\n    width:100px;\n    height:100px;\n    background-color:blue;\n}\n//调用这个代码块\n.div{\n    @include init;\n}\n```\n为mixin指定参数和缺省值\n```\n@mixin width($width:50){   //可以指定默认值，这里是50\n  width:$width px;\n}\n.div1{\n  @include width(200); //200px\n}\n.div2{\n  @include width();  //50px\n```\nmixin允许有多个参数\n```\n@mixin mul($width:100,$height:100,$background:blue){\n  width:$width px;\n  height:$height px;\n  background-color: $background;\n}\n.div{\n  @include mul();\n}\n```\nmixin最常用的地方就是css3的hack代码(如border-radius等)\n```\n@mixin rounded($v,$h,$radius:5px){\n　　-webkit-border-#{$v}-#{$h}-radius: $radius;\n　　-moz-border-radius-#{$v}#{$h}: $radius;\n　　border-#{$v}-#{$h}-radius: $radius;\n}\n```\n<br>\n#### 6.继承\nSass的继承类似于高级程序设计语言的继承，可以使用@extend从一个选择器(占位符)继承它的样式。\n```\n.father{\n  width:100px;\n  height:100px;\n  background-color: black;\n}\n.son{\n  @extend .father;  //继承了.father的所有样式\n  border-width:2px;\n}\n```\n占位符：要实现继承必须有父类，也就是必须要有一个选择器来实现被继承，但是这个父选择器最终也会被编译成css样式。Sass提供了占位符这个功能来实现类似于接口的功能，可以为占位符设定样式，占位符可以被继承并且它最终不会被编译到css文件中，这个功能大大减少了css代码。\n```\n%father{\n  width:100px;\n  height:100px;\n  background-color: black;\n}\n.son{\n  @extend %father;  //继承了%father的样式，但是%father最终不会被编译\n  border-width:2px;\n}\n```\n<br>\n#### 7.函数\nSass提供了一些函数，其中最常用的是color函数。用户也可以自己定义函数。\n常用的color函数:lighten($color,$amount)和darken($color,$amount)代表颜色减淡和加深,第一个参数为颜色，第二个参数为百分比。\n```\nbody{\n  background-color: lighten(black,50%);//gray\n}\n```\n自定义函数\n```\n@function myfunction($width){\n  @return $width*2 px;\n}\n.div3{\n  width:myfunction(300);\n}\n```\n<br>\n#### 8.运算\nSass支持变量之间以及变量直接和数值的运算，要注意运算符前面要有一个空格。用法同Sass，这里就不详细叙述了。\n条件语句@if和@else：\n```\n$var:100;\n.div{\n    @if($var==100){\n    width:100px;\n}\n    @else{\n    width:200px;\n}\n```\n三目判断if(condition,true,false)第一个参数代表条件，第二个参数代表为真的时候的值，第三个代表为假的时候的值。\n```\n$var:100;\n.div{\n    width:if($var==100,200px,300px);   //width:200px\n}\n```\n循环@for、@while\n```\n@mixin block{\n    width:100px;\n    height:100px;\n    background-color:black;\n}\n@for $i from 1 through 10{    //through包括10而to不包括10\n  .item-#{$i}{\n    @include block;//.item-1 —— .item10:{}\n  }\n}\n```\n使用@each来遍历\n单个list字段\n```\n$i:1,2,3,4,5,6,7,8,9,10;\n@each $temp in $i{\n  .item-#{$temp}{\n    border:1px solid red;\n  }\n}\n```\n多个list字段\n```\n$i:(1,blue),(2,grey),(3,yellow),(4,red),(5,black),(6,green),(7,white),(8,gold),(9,blue),(10,red);\n@each $temp1,$temp2 in $i{\n  .item-#{$temp1}{\n    background-color: $temp2;\n  }\n}\n```\n遍历map字段\n```\n$map:(h1:2em,h2:3em,h3:4em);\n@each $key,$value in $map{\n  #{$key}{\n    font-size:$value;\n  }\n}\n```","tags":["css"],"categories":["技术博客"]},{"title":"Less初学","url":"/2016/02/23/2016-02-23-technology-less/","content":"### 什么是Less\n官方文档上面说：Less 是一门 CSS 预处理语言，它扩展了 CSS 语言，增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展。\n\n说白了Less就是动态的CSS，也就是具备函数、变量、控制语句的CSS。要知道，很多时候CSS都需要对同一个样式重复写很多遍，Less使得CSS的编写更加简单和方便。\n<br>\n### 如何使用Less\nLess可以通过npm来安装\n```\n$ npm install -g less\n```\n我使用的是第三方的GUI——koala\nkoala使用起来非常简单，只需要将Less所在的文件夹放置到koala中配置好输出路径就可以正常使用Less来完成预处理，并且koala自带错误提示功能。\n下载地址：http://koala-app.com/index-zh.html\n### Less详解\n#### 注释\nLess新增了“//”注释法，更贴近与程序设计语言。这种注释方法在编译的时候不会被保留，也就是生成的css文件中这个注释会被 pass掉。而“/**/”这种注释法在编译的时候会被保留。\n<br>\n#### 变量\nLess的变量声明方法为：@+变量名\n```\n@myColor:red;\ndiv{\n  background:@myColor;\n}\n```\n编译后的css为\n```\ndiv{\n  background:red;\n}\n```\n<br>\n#### 混合\n什么是混合?我个人将它理解成css版本的函数\n```\n.border{\n  border:1px solid black;\n}\n.box{\n  color:white;\n  background:red;\n  .border;//应用.border的样式  \n}\n```\n有人会问：这个Less哪里简单了，感觉反而更麻烦了。别急，往下面看。\n<br>\n#### 带参数的混合\n带参数的混合就更好理解了，它更向函数去靠近了\n```\n.border(@myWidth){\n  border:@myWidth solid black;\n}\n.box{\n  color:white;\n  background:red;\n  .border(3px);//传入参数\n}\n```\n当然，混合也可以指定默认的参数，这样就不必每次都给它传参啦\n```\n.border(@myWidth:3px){\n  border:@myWidth solid black;\n}\n.box{\n  color:white;\n  background:red;\n  .border();//这里可以不用传参了，但是必须要有括号！\n}\n```\n再看一个例子，css3针对不同浏览器做了hack，也就是增加前缀，这种hack方法的确实现了兼容各浏览器开发，但是带来的弊端就是我们必须去写大量的hack代码，不仅浪费时间，整个css文件也十分臃肿。\n\n下面是使用Less来解决这一问题\n```\n.border(@width:3px){\n  -webkit-border-radius:@width;\n  -moz-border-radius:@width;\n  -ms-border-radius:@width;\n  border-radius:@width;\n}\ndiv{\n  background:red;\n  height:100px;\n  width:100px;\n  .border(50px);\n}\n```\n表面上看起来并不简单，但是当需要多个地方使用这个border-radius的时候只需要调用.border()就可以了而不必再去写重复的代码。把它映射到高级程序设计语言中，是封装一个函数每当需要的时候去调用它方便还是每次都重新敲一遍代码方便？\n<br>\n#### 匹配模式\n这个有点像if语句，但是和if又有很大的区别，它是根据传入不同的参数来执行不同的样式操作\n```\n.color(r,@width:50px,@height:50px)//如果第一个参数是r则使用该样式\n{\n  background:red;\n}\n.color(b,@width:50px,@height:50px)//如果第一个参数是b则使用该样式\n{\n  background:blue;\n}\n.color(y,@width:50px,@height:50px)//如果第一个参数是r则使用该样式\n{\n  background:yellow;\n}\n.color(@_,@width:50px,@height:50px)\n{\n  width:@width;\n  height:@height;\n  .border(10px);\n}\n```\n这里就和if语句不一样了，Less是根据传入的参数的不同来选择究竟进入到哪个“函数之中”。代码的最后一段有一个@_参数，它的意思是，无论匹配是否成功都会进入到这里\n```\ndiv{\n  .color(r);\n}\n```\n上述代码编译后的css为\n```\ndiv{\n  background:red;\n  width:50px;\n  height:50px;\n}\n```\n那么如果我输错了参数会怎样？\n```\ndiv{\n  .color(g);\n}\n```\n编译后的css就变为\n```\ndiv{\n  width:50px;\n  height:50px;\n}\n```\n无论匹配是否成功，最终都会应用带有@_参数的样式。\n<br>\n#### 运算\nLess支持变量的运算。比如\n```\n@myWidth:300px;\ndiv{\n  width:@myWidth-100;\n}\n```\n最终div的宽度就是200px，可以看到100并没有加单位px，因为@myWidth已经有单位了，所以100可以不用加单位，但是为了更加直观最好还是加上单位。\n<br>\n#### 嵌套\n嵌套可以说是Less最有意思的功能，也是最实用的功能。\n举个例子，如果需要创建一个导航栏，样式可能会这样写\n```\nul {\n  width: 500px;\n  margin: 30px auto;\n  padding: 0px;\n  list-style: none;\n}\nul li {\n  height: 30px;\n  line-height: 30px;\n  margin-bottom: 3px;\n  background: green;\n}\nul li a {\n  float: left;\n}\nul li a:hover {\n  color: blue;\n}\nul li span {\n  float: right;\n}\n```\n这种写法十分标准，它告诉了我们哪个位置的a标签应用了这个样式，而且标签和标签的嵌套关系也十分明了。但是如果父层的类名十分长，这种写法就比较麻烦了。\n\n而Less模仿了html的嵌套语法\n```\nul{\n  width:500px;\n  margin:30px auto;\n  padding:0px;\n  list-style: none;\n  li{\n     height:30px;\n     line-height:30px;\n     margin-bottom:3px;\n     background:green;\n     a{\n       float:left;\n       &:hover{//匹配上一级元素，也就是a\n               color:blue;\n              }\n      }\n     span{\n          float:right;\n      }\n   }\n}\n```\n代码中&代表着匹配它的父级选择器，在上述代码里&的父级选择器是a，也就是a:hover。","tags":["css"],"categories":["技术博客"]}]